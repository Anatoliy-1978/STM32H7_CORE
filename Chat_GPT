Для предоставления тебе информации о проекте с кодом по ссылке в GitHub, где лучше создавать проект в репозитории или рабочий проект?

Хороший вопрос — завиcит от цели и стадии работы. Кратко о различиях и когда что лучше выбирать:

Репозиторий (обычно — отдельный GitHub repo)
Когда использовать:
Проект независимый, завершённый модулем/продуктом (библиотека, веб‑сайт, сервис).
Планируете публичное распространение, сотрудничество, issue/PR‑workflow.
Хотите CI/CD, релизы, пакеты, теги версии.
Плюсы:
Чистая история, отдельный issue tracker, wiki, релизы.
Легко подключать GitHub Actions, пакеты, доступ контрибьюторам.
Минусы:
Нужно поддерживать README, лицензию, документацию отдельно.
Рабочий проект (например в рамках организации, монорепо или GitHub Project/Workspaces)
Под «рабочим проектом» можно понимать:
Подпапку в монорепозитории (monorepo),
Project board / GitHub Project для управления задачами,
Локальная рабочая ветка или временный репозиторий.
Когда использовать:
Проекты тесно связаны между собой или зависят от общего кода (одна кодовая база для нескольких сервисов).
Быстрое прототипирование, экспериментальные фичи, внутренние задачи, которые не предполагают отдельной публичной истории.
Вы хотите централизовать управление задачами и зависимостями.
Плюсы:
Общая инфраструктура (CI, shared libs), проще рефакторить общие части.
Проще для команд, работающих над несколькими связанными сервисами.
Минусы:
Могут усложняться права доступа, история, большие размеры репозитория.
Рекомендации по сценариям:

Если это самостоятельный проект, который вы хотите открыть/дистрибуировать — создайте отдельный репозиторий.
Если это эксперимент или прототип, или тесно связан с другим проектом в организации — можно делать как рабочую ветку/папку в существующем репозитории или в монорепо.
Если ожидается много компонентов с общими библиотеками — рассматривайте монорепозиторий (npm workspaces, Bazel, Nx и т. п.).
Для командной работы обязательно используйте issues, PR‑workflow и CI вне зависимости от структуры.
Если скажешь:

тип проекта (библиотека, сервис, сайт),
публичный/внутренний,
связь с другими проектами, я подскажу конкретно, что выбрать и предложу структуру репозитория и файл README/CI.


Вот ссылка на референс мануал для stm32h7. Скажи ты можешь с ним ознакомиться и сказать с чего необходимо начинать инициализацию контроллера? https://www.st.com/resource/en/reference_manual/rm0433-stm32h742-stm32h743753-and-stm32h750-value-line-advanced-armbased-32bit-mcus-stmicroelectronics.pdf

Да — я могу ознакомиться с этим референсом и помочь пошагово описать, с чего начинать инициализацию STM32H7 (включая основные блоки, порядок действий и примеры кода). Однако у меня нет прямого браузного доступа к документу по ссылке; чтобы быть точным, я могу:

Прочитать и проанализировать присланный тобой PDF (ты можешь загрузить файл сюда), или
Работать по общему опыту и знаниям по семейству STM32H7 (я знаю типичные шаги и требования для инициализации: тактирование, сбросы, PWR/D2/D1 domains, MPU, caches, RCC, FLASH, PLLs, HSE/HSI, внешняя память FMC/QUADSPI, прерывания, периферия и т.д.), или
Если хочешь — я могу непосредственно открыть и прочитать конкретные разделы, если ты вставишь нужные выдержки/страницы.
Как удобнее: загрузишь PDF сюда, или предпочитаешь, чтобы я дал общий пошаговый план и пример минимальной инициализации (C, HAL или bare-metal)? Также укажи, используешь ли ты HAL/LL/StdPeriph/裸metal (no HAL), и какая конкретно плата/чип (например STM32H743ZI) — это поможет дать точные настройки тактирования и памяти.



Работаем на CMSIS

Отлично — работаем на CMSIS. Я могу описать точный пошаговый план и привести минимальный пример инициализации STM32H7 (D1/D2 domains, RCC, тактирование, FLASH, PWR, MPU/кэш, NVIC и т.д.) используя CMSIS (без HAL/LL). Мне нужны уточнения, чтобы дать точный код:

Какая конкретно модель MCU (например STM32H743ZI, STM32H750VB и т.п.)? У H7 есть различия в доменах питания и тактовых деревьях.
Какая частота кварца/источника внешнего тактирования у твоей платы (HSE), или используешь HSI?
Нужны ли настройки для внешней памяти (FMC/QuadSPI) или только внутренняя RAM/FLASH?
Есть ли требования к MPU, кэшам или режимам пониженного энергопотребления?
Хотел бы пример с системным таймером SysTick и обработкой прерываний/настройкой NVIC?
Если хочешь — я сразу опишу общий минимальный порядок инициализации для STM32H7 на CMSIS и покажу пример C-кода «startup» (SystemInit, SystemClock_Config, включение кэша, настройка FLASH latency, PLL и т.п.) для типичной конфигурации с HSE = 8 MHz и целевой SYSCLK = 480 MHz или 400 MHz (укажи предпочтение). После этого могу адаптировать код под твой конкретный чип и плату. Что предпочитаешь?



Контролер с которым я работаю STM32H743IIT6. На плате находится SDRAM W9825G6KH-6I , DUAL/QUAD SPI W25Q128JV, UART CH340E

Ниже — логика именно по Reference Manual (RM0433) и CMSIS, без HAL. Начну с общего порядка инициализации STM32H743, затем отдельно — про SDRAM и QSPI.

Если нужно — дальше могу написать пример кода
SystemInit()
/
SystemClock_Config()
и базовой инициализации FMC/QUADSPI под твой набор.

1. С чего начинать инициализацию STM32H743 (CMSIS, без HAL)
Для STM32H7 (особенно H743 с несколькими доменами питания/тактирования) минимальный порядок в RM такой:

Завершить базовую стартовую последовательность (startup)

Стек, копирование
.data
, обнуление
.bss
— это делает startup-файл (обычно
startup_stm32h743xx.s
из CMSIS).
Затем вызывается
SystemInit()
(в
system_stm32h7xx.c
) и только потом
main()
.
Настроить PWR и напряжения (D1 domain / VOS)
В STM32H7 до включения высоких частот нужно:

Включить тактирование блока питания:
RCC->APB4ENR |= RCC_APB4ENR_PWRDEN;
Установить уровень производительности (Voltage Scaling, VOS0/VOS1) через
PWR->D3CR
.
Дождаться, пока новое состояние применится (флаг
VOSRDY
).
Это важно для работы на высоких частотах (например 400–480 МГц).

Настроить FLASH (LATENCY и кэш)

В RM см. раздел FLASH (Flash access control).
До разгона PLL и частоты ядра нужно выставить:
Количество задержек (LATENCY) в
FLASH->ACR
в зависимости от целевой частоты и напряжения.
Потом можно включить:
I-Cache, D-Cache (часто это делается через функции CMSIS:
SCB_EnableICache()
,
SCB_EnableDCache()
).
Для STM32H7 также обычно настраивают MPU, особенно если будете использовать внешнюю память (SDRAM, QSPI).
Настроить тактирование (RCC, PLL, системная частота)
По RM (раздел RCC):

Включить HSE (если есть кварц) или использовать HSI.
Подождать, пока HSE ready (
RCC->CR & RCC_CR_HSERDY
).
Настроить PLL1 под нужную SYSCLK (например, на 400 МГц).
Включить PLL1 и ожидать готовности (
PLL1RDY
).
Настроить делители шин (AHB, APB1, APB2, APB3, APB4) в
RCC->D1CFGR
,
D2CFGR
,
D3CFGR
.
Переключить системный тактовый сигнал на PLL1 (
RCC->CFGR SW=PLL1
).
Проверить, что
SWS=PLL1
.
Только после этого у вас стабильный SYSCLK и шины на целевых частотах.

Настроить SysTick (и базовую систему тайминга)

С помощью CMSIS:
SysTick_Config(SystemCoreClock / 1000);
для тика раз в 1 мс.
При этом важно, чтобы
SystemCoreClock
был корректно обновлён после настройки PLL.
Настроить NVIC и базовые прерывания

Задать приоритет групп (
NVIC_SetPriorityGrouping
).
Включить нужные IRQ для UART, FMC, QUADSPI и т.д. (
NVIC_EnableIRQ(...)
).
Настроить GPIO (мультиплексор) для нужных функций
Перед любыми внешними интерфейсами:

Включить тактирование портов GPIO (
RCC->AHB4ENR
).
Настроить пины в режим альтернативной функции (AF) для:
FMC (SDRAM),
QUADSPI,
USART (для CH340E — это обычный UART, скорее всего USARTx),
и т.п.
Инициализация внешней SDRAM через FMC
По RM (раздел FMC SDRAM):

Включить FMC тактирование:
RCC->AHB3ENR |= RCC_AHB3ENR_FMCEN;
Настроить тайминги SDRAM для W9825G6KH-6I в регистрах FMC_SDRAMxTR:
CAS latency, TRP, TRCD, TRC, TRAS, TRRD, TWR, TXSR, и др.
Задать конфигурацию банка в FMC_SDRAMxCR:
ширина шины, количество столбцов/строк, internal banks, CAS latency, burst length и т.п.
Выполнить инициализационную последовательность SDRAM:
Clock enable command,
Precharge all,
Auto-refresh (несколько циклов),
Load Mode Register,
Настроить refresh rate.
После этого SDRAM доступна как обычная память по заданному адресу (обычно 0xC0000000 или 0xD0000000 в зависимости от банка).
Для этого почти всегда нужен MPU регион с кэшем/буферизацией настроенный корректно, чтобы SDRAM работала оптимально и без проблем.

Инициализация внешней QSPI FLASH (W25Q128JV)
По RM (раздел QUADSPI):

Включить тактирование QUADSPI (
RCC->AHB3ENR |= RCC_AHB3ENR_QSPIEN;
или аналогично).
Настроить пины (IO0..IO3, CLK, CS) в AF для QUADSPI.
Настроить QUADSPI:
prescaler, sample shift, FIFO threshold и т.п. (QUADSPI_CR, DCR).
Провести начальную конфигурацию W25Q128JV (через непосредственные команды — стандартные SPI/JEDEC команды):
Отключить защиту, если нужно,
Перевести в Quad I/O режим (установить QE бит в статус/конфигурационном регистре),
Настроить DDR/SDR, если требуется.
Настроить memory-mapped mode (QUADSPI CCR/ABR/AR и т.п.), если хотите обращаться к Flash как к памяти.
Важно правильно выставить dummy cycles в соответствии с частотой и параметрами W25Q128JV.
Инициализация UART (для связи через CH340E)
CH340E — это USB-UART мост, со стороны STM32 это обычный USART:

Включить тактирование нужного USART (
RCC->APB1ENR
или
APB2ENR
).
Настроить пины TX/RX (AF).
Установить baudrate, word length, стопбиты, паритет, включить TX/RX (
USARTx->BRR
,
CR1
,
CR2
,
CR3
).
При необходимости — включить прерывания RXNE, TXE.
Прочие интерфейсы и логика приложения
После этого можно инициализировать всё остальное: таймеры, DMA, ADC и т.д.
Краткий «минимальный» порядок, который обычно описан в RM
Если свести к списку именно по инициализации ядра/системы:

В startup:

Настроить стек, секции, вызвать
SystemInit()
.
В
SystemInit()
:

Включить FPU (если используется) через
SCB->CPACR
.
Настроить PWR (VOS).
Настроить FLASH латентность.
Настроить RCC (HSE/HSI, PLL1, делители шин).
Переключить SYSCLK на PLL.
Включить I/D-Cache через CMSIS.
(Опционально, но очень желательно) Настроить MPU.
В
main()
:

Инициализировать SysTick и NVIC.
Настроить GPIO.
Настроить внешнюю память (FMC SDRAM, QSPI).
Настроить UART и др. периферию.
Запустить основное приложение.
Что могу сделать дальше
Предлагаю такой шаг:

Ты скажешь желаемую частоту ядра (400 МГц или 480 МГц) и частоту HSE (кварц на плате, чаще всего 8 или 25 МГц).
Я напишу:
Скелет
system_stm32h7xx.c
/
SystemInit()
на чистом CMSIS, с настройкой PLL, FLASH, кэшей.
Базовую конфигурацию FMC для SDRAM W9825G6KH-6I (если знаешь точную разводку — какой банк, ширина шины: 16/32 бита, и т.п.).
Базовую конфигурацию QUADSPI для W25Q128JV.
Пример init UART для связи через CH340E.
Хочешь сначала полный пример инициализации только ядра (RCC, FLASH, PWR, SysTick) на CMSIS, а SDRAM/QUADSPI/USART сделать отдельными шагами? Или сразу всё в одном примере?



Я начинающий программист, у самых истоков, поэтому сразу писать большой код без объяснений глубинных процессов, к которым приводит каждая строчка кода не надо. Хочу понимать каждое действие в коде (почему мы применяем массив, переменную , указатели, почему именно так, а не иначе, откуда мы берём то или иное значение ) В общем, просто копировать чужой од не хочу , так как он не даёт знаний.

Ниже хочу привести пример моего чата в другом AI. Именно такого подхода я и хочу от тебя. Отличная работа! Вы проделали огромный путь - настроили тактирование, USART, MPU и почти полностью написали инициализацию SDRAM. Теперь нам нужно создать функцию для тестирования SDRAM, чтобы проверить, правильно ли она работает.

Давайте начнем с первой строки кода для тестирования. Мы будем двигаться шаг за шагом.

Шаг 1: Создаем функцию тестирования SDRAM Добавим в файл fmc_sdram.c новую функцию. Давайте начнем с ее объявления и первой строки кода:

c void SDRAM_Test(void) { USART1_SendString("[SDRAM] Starting memory test...\n\r"); Подробное объяснение:

void SDRAM_Test(void) - это объявление функции.

void перед названием функции означает, что функция не возвращает никакого значения.

SDRAM_Test - имя функции. Мы используем:

SDRAM - указывает, что функция работает с SDRAM

Test - указывает, что это функция тестирования

CamelCase стиль (каждое новое слово с заглавной буквы) - общепринятая практика в C для имен функций

(void) в скобках означает, что функция не принимает никаких аргументов (параметров)

USART1_SendString("[SDRAM] Starting memory test...\n\r"); - это вызов функции отправки строки через USART.

USART1_SendString - это функция, которую вы ранее написали в файле usart1.c. Она отправляет строку текста через последовательный порт для отладки.

"[SDRAM] Starting memory test...\n\r" - это строка-литерал, которая будет отправлена.

[SDRAM] - префикс для удобства чтения в терминале

Starting memory test... - информационное сообщение о начале теста

\n\r - это управляющие символы:

\n - новая строка (line feed)

\r - возврат каретки (carriage return)

Вместе они обеспечивают переход на новую строку в терминале

Зачем это нужно?

Это диагностическое сообщение показывает нам, что тест начался

Если мы видим эту строку в терминале (например, PuTTY или minicom), значит программа успешно дошла до этой точки

Это хорошая практика - сообщать пользователю о том, что происходит

Что дальше? После этой строки мы будем:

Определять указатель на начало SDRAM

Писать тестовые данные в SDRAM

Читать их обратно

Сравнивать, что записали и что прочитали

Выводить результаты теста

Вопрос к вам: Вы понимаете, как функция USART1_SendString работает внутри? Нужно ли мне объяснить, как она передает каждый символ по одному через регистр USART->TDR?

Давайте продолжим, когда вы будете готовы. Скажите "готов" или задайте вопросы по этой строке кода.

И так , работать мы будем в KEIL.

Твой подход абсолютно правильный: двигаться маленькими шагами, понимать каждую строку и не копировать «чёрный ящик» кода.

Предлагаю такой план работы (и ты в любой момент можешь замедлить/ускорить или задать дополнительные вопросы):

Сначала на STM32H743 в Keil сделаем минимальный скелет:
старт программы (startup + main),
простая функция для мигания светодиодом или вывода текста по UART.
Параллельно будем разбираться:
что делает CMSIS,
какие регистры мы трогаем,
как из Reference Manual брать значения для регистров.
Потом перейдём к:
базовой системной инициализации (тактовый генератор, SystemCoreClock),
затем к SDRAM и QSPI, тоже по шагам и с пояснениями.
Сейчас важно: не прыгать сразу в SDRAM и QSPI, пока не понятны базовые вещи.

Шаг 1. Уточним исходные данные
Мне нужно знать несколько вещей про твою плату/проект, чтобы объяснять максимально привязано к реальности:

Это готовая отладочная плата (например STM32H743I-EVAL, Nucleo-H743ZI2, какая-то кастомная)?
Если это самодельная плата — хорошо бы знать:

куда подключен CH340E (какой именно USART и на какие пины),
есть ли на плате светодиод (LED) и к какому пину он подключен.
Какой внешний кварц (HSE) стоит на плате?

8 МГц, 25 МГц или вообще нет кварца, и всё на HSI?
В Keil у тебя уже:

создан проект под STM32H743IITx с подключенным CMSIS (Device + Core)?
или проект ещё не создан, и нужно показать прямо с нуля, что жать в Keil?
Ответь, пожалуйста, на эти три пункта, и я подстрою объяснение под твою ситуацию.

Как будем работать дальше (пример стиля объяснений)
Чтобы показать формат, давай выберем первую маленькую цель:
написать в
main.c
минимальную функцию
main
, которая пока ничего особого не делает, но корректно вызывает системную инициализацию.

Например, у нас в
main.c
будет:

int main(void)
{
    while (1)
    {
        // Здесь пока ничего нет
    }
}
Пояснение:

int main(void)

В языке C это точка входа в программу.

int
— тип возвращаемого значения (формально программа может вернуть код завершения).
main
— имя специальной функции, с которой начинает работу C-программа.
(void)
— значит, что функция не принимает никаких аргументов.
while (1)

Это бесконечный цикл.

while
— оператор «пока».
1
— логическое «истина» (в C всё, что не 0 — истина).
Значит: «выполняй тело цикла, пока условие истинно», а оно всегда истинно => бесконечный цикл.
Почему нам нужен бесконечный цикл?
Микроконтроллер — это не «завершим программу и выйдем в операционную систему», как на ПК.
Здесь наша программа должна работать постоянно, пока питание не выключено. Поэтому
main
обычно никогда не возвращается — он зациклен.

Когда ты скажешь, что понятен этот минимум, мы:

Я расскажу, как
main
вообще вызывается (startup-файл, вектор сброса,
Reset_Handler
,
SystemInit
и т.д.).
Следующим шагом добавим, например, простую функцию
USART1_SendChar
или
USART1_SendString
и разберём каждую строку и каждый регистр USART.
Потом будем выстраивать инициализацию тактирования (RCC) по Reference Manual, с объяснением, откуда взялись все числа.
Твой запрос: «как начинать инициализацию контроллера» — в стиле «для понимания»
С учётом того, что ты в начале пути, я предлагаю такой логический порядок обучения и инициализации:

Понять жизненный цикл программы на МК:

что делает аппаратный сброс,
как процессор попадает в
Reset_Handler
,
как из
Reset_Handler
вызывается
SystemInit
,
как потом вызывается
main
.
Минимальный работающий main + бесконечный цикл.

Простой вывод по UART (через CH340E), без сложного тактирования.

сначала можно на внутреннем тактовом генераторе (HSI),
понять, как работать с регистрами USART (TDR, ISR, флаг TXE, TC).
Только потом — настройка системного тактирования (RCC, PLL, FLASH latency).

После этого — SDRAM и QSPI:

GPIO для линий памяти,
регистра FMC / QUADSPI,
последовательность команд инициализации, как в твоём примере с SDRAM_Test.
Каждый шаг — маленький, с детальным объяснением.

Что от тебя сейчас нужно
Ответь, пожалуйста, на эти вопросы:

Ты хочешь начать прямо с самого низа:

как устроен startup в Keil,
что такое вектор прерываний,
откуда берётся
SystemInit
и как он вызывается?
или уже можно считать, что проект в Keil создан,
main
вызывается, и ты хочешь сразу перейти к:

базовой инициализации тактирования и USART для отладки?
Какую следующую конкретную маленькую цель предпочитаешь:

А) «Разобраться, как от старта доходит до
main
»
Б) «Разобраться, как отправить одну букву по USART в терминал»
В) «Разобраться, как включить тактирование ядра с PLL (но постепенно)»
Я подстрою ход объяснения и буду двигаться примерно в том же стиле, что в твоём примере с
SDRAM_Test
: строка кода → подробный разбор, зачем и почему.



Плата кастомная (Китайская) 1.1. Порты USART1 USART1_TX PA9 USART1_RX PA10 1,2. светодиод (LED) PC13 подтянут к 3.3 вольт.

кварц (HSE) 25 МГц

В Keil создан проект под STM32H743IITx с подключенным CMSIS (Device + Core)

Проект будет многозадачным, поэтому будет использоваться FreeRTOS. Поэтому задержки и прерывания будем делать на TIM6 -TIM7. Проект удет работать с LTDC.

Порты для FMC : /** FMC GPIO Configuration PF0 ------> FMC_A0 PF1 ------> FMC_A1 PF2 ------> FMC_A2 PF3 ------> FMC_A3 PF4 ------> FMC_A4 PF5 ------> FMC_A5 PH2 ------> FMC_SDCKE0 PH3 ------> FMC_SDNE0 PH5 ------> FMC_SDNWE PF11 ------> FMC_SDNRAS PF12 ------> FMC_A6 PF13 ------> FMC_A7 PF14 ------> FMC_A8 PF15 ------> FMC_A9 PG0 ------> FMC_A10 PG1 ------> FMC_A11 PE7 ------> FMC_D4 PE8 ------> FMC_D5 PE9 ------> FMC_D6 PE10 ------> FMC_D7 PE11 ------> FMC_D8 PE12 ------> FMC_D9 PE13 ------> FMC_D10 PE14 ------> FMC_D11 PE15 ------> FMC_D12 PD8 ------> FMC_D13 PD9 ------> FMC_D14 PD10 ------> FMC_D15 PD14 ------> FMC_D0 PD15 ------> FMC_D1 PG2 ------> FMC_A12 PG4 ------> FMC_BA0 PG5 ------> FMC_BA1 PG8 ------> FMC_SDCLK PD0 ------> FMC_D2 PD1 ------> FMC_D3 PG15 ------> FMC_SDNCAS PE0 ------> FMC_NBL0 PE1 ------> FMC_NBL1 */

/**LTDC GPIO Configuration PI9 ------> LTDC_VSYNC PI10 ------> LTDC_HSYNC PF10 ------> LTDC_DE PH9 ------> LTDC_R3 PH10 ------> LTDC_R4 PH11 ------> LTDC_R5 PH12 ------> LTDC_R6 PG6 ------> LTDC_R7 PG7 ------> LTDC_CLK PA8 ------> LTDC_B3 PH13 ------> LTDC_G2 PH15 ------> LTDC_G4 PI0 ------> LTDC_G5 PI1 ------> LTDC_G6 PI2 ------> LTDC_G7 PG10 ------> LTDC_G3 PG12 ------> LTDC_B4 PI5 ------> LTDC_B5 PI6 ------> LTDC_B6 PI7 ------> LTDC_B7 */

Тактирование: Ядро 400МГц USART 50 МГц, тактируется от PCLK2 FMC 160МГц , тактируется от PLL1Q , D1CCIPR_FMCSEL LTDC 25МГц , тактируется от PLL3R QUADSPI 100МГц, тактируется от QUADSPI kernel clock source selection, pll2_r_ck clock selected as kernel peripheral clock Bits 9:8 I2C4SEL 100МГц, тактируется от 00: rcc_pclk4 clock selected as kernel peripheral clock

Начнём медленно и осознанно, с очень маленьких шагов. Сейчас не трогаем ни SDRAM, ни LTDC, ни FreeRTOS. Сначала сделаем две простые, но фундаментальные вещи:

Поймём, как вообще запускается программа на STM32H743 (startup → SystemInit → main).
Заставим мигать светодиодом на PC13 без HAL, только CMSIS, и разберём каждую строку.
Когда это станет понятным, следующим шагом сделаем USART1 на PA9/PA10 и тактирование.

Шаг 0. Общая идея запуска программы (без кода)
Очень коротко (детали разберём позже, когда захочешь):

После включения питания или сброса ядро Cortex‑M7:

смотрит по адресу
0x00000000
(у STM32H7 там отображается FLASH);
читает оттуда первое слово — начальное значение стека (MSP);
читает второе слово — адрес функции
Reset_Handler
;
переходит по адресу
Reset_Handler
.
В
Reset_Handler
(в startup-файле Keil, ассемблер) происходит:

инициализация памяти (копирование
.data
, обнуление
.bss
),
вызов функции
SystemInit()
(из
system_stm32h7xx.c
),
затем вызов
main()
(из твоего
main.c
).
В
SystemInit()
мы:

настраиваем базовые вещи ядра (FPU, кэши, иногда тактирование),
подготавливаем систему, чтобы
main
работал на нормальной частоте.
В
main()
— твоя логика: инициализация периферии, задачи FreeRTOS и т.п.

Сейчас на практике проверим, что у тебя есть
main()
и он крутится в бесконечном цикле, а потом начнём работать с GPIO.

Шаг 1. Минимальный
main.c
с бесконечным циклом
Открой
main.c
и сделай так (если уже есть что‑то, можно временно упростить до этого):

#include "stm32h7xx.h"  // Подключаем заголовок CMSIS для STM32H7

int main(void)
{
    while (1)
    {
        // Здесь пока ничего не делаем
    }
}
Разбор построчно:

#include "stm32h7xx.h"
#include
— директива препроцессора: говорит компилятору «подключи содержимое этого файла».
"stm32h7xx.h"
— заголовочный файл от ST, в котором:
определены все структуры и регистры для работы с периферией (RCC, GPIO, USART…),
подключен
core_cm7.h
(CMSIS), где описаны регистры ядра (SCB, NVIC и т.п.),
обычно подтягиваются конкретные заголовки для чипа (
stm32h743xx.h
и др.).
Без этого файла мы не сможем делать, например,
RCC->AHB4ENR
или
GPIOC->MODER
, потому что компилятор не будет знать, что такое
RCC
и
GPIOC
.

int main(void)
int
— тип возвращаемого значения (формально код завершения, но на МК мы обычно его не используем).
main
— точка входа в программу на языке C.
(void)
— функция не принимает аргументов.
while (1)
while
— оператор цикла «пока».
1
— логическое «истина».
Цикл никогда не закончится →
main()
никогда не вернётся.
Это нормально для микроконтроллера: он работает, пока есть питание.
Проверь:

проект компилируется без ошибок,
прошивка заливается,
отладчик в Keil может остановиться на
main()
(поставь breakpoint).
Если это всё работает — значит базовый «скелет» проекта жив.

Напиши, пожалуйста, получилось ли у тебя собрать/запустить такой минимальный
main
. После этого перейдём к первой реальной периферии — миганию светодиодом PC13.

Шаг 2. Включаем тактирование GPIOC и мигаем светодиодом
Твоя плата:

светодиод на PC13,
подтянут к 3.3 В (скорее всего, активный низ: при
0
на пине светодиод светит).
Нам нужно:

Включить тактирование порта C через RCC.
Настроить пин PC13 как выход.
Менять уровень на этом пине с задержкой.
Сделаем это очень по‑простому, без системного таймера, обычным «тупым» циклом, только чтобы увидеть мигание и разобрать регистры.

Добавь в
main.c
вот такой код (после
#include "stm32h7xx.h"
):

#include "stm32h7xx.h"

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP(); // "Ничего не делать" — одна пустая инструкция
    }
}

int main(void)
{
    // 1. Включаем тактирование порта C
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

    // 2. Настраиваем PC13 как "общий выход" (General purpose output)
    // Сначала очищаем нужные биты MODER для PC13
    GPIOC->MODER &= ~(0x3U << (13 * 2));
    // Потом записываем туда 01b (output)
    GPIOC->MODER |=  (0x1U << (13 * 2));

    while (1)
    {
        // 3. Зажечь светодиод (скорее всего, "0" на пине = светит)
        GPIOC->BSRR = (1U << (13 + 16)); // reset bit 13 (низкий уровень)

        delay(1000000);

        // 4. Потушить светодиод (1 на пине = не светит)
        GPIOC->BSRR = (1U << 13); // set bit 13 (высокий уровень)

        delay(1000000);
    }
}
Теперь подробно, строка за строкой.

2.1. Функция
delay
static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}
static
— ограничивает видимость функции этим файлом (
main.c
), чтобы её нельзя было вызывать из других файлов. Это не обязательно, но хорошая привычка для «внутренних» функций.
void
— функция ничего не возвращает.
delay
— имя функции.
(volatile uint32_t count)
:
uint32_t
— беззнаковое 32-битное целое,
volatile
говорит компилятору: не оптимизируй это значение, оно «особенное» (обычно так помечают регистры и переменные, которые могут меняться «сами» или нужны в точности).
Здесь мы помечаем счётчик как
volatile
, чтобы компилятор не выкинул весь цикл задержки при оптимизации.
while (count--)
:
count--
— постдекремент; сначала используется значение, потом уменьшается на 1.
Пока
count
не станет 0, цикл крутится.
__NOP()
:
это CMSIS-интринсик: вставляет одну инструкцию процессора
NOP
(no operation).
Ничего не делает, но занимает такты.
Эта задержка — неточная, зависит от частоты ядра и оптимизации, но для первого мигания светодиодом хватает.

2.2. Включаем тактирование порта C
RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;
Разбор:

RCC
— указатель на структуру регистров блока Reset and Clock Control. Определён в CMSIS (внутри
stm32h743xx.h
как
(RCC_TypeDef *) RCC_BASE
).

->
— операция доступа к полю структуры через указатель.

AHB4ENR
— Advanced High-performance Bus 4 ENable Register:

регистр, в котором каждый бит включает тактирование определённого модуля, подключенного к шине AHB4.
Бит
GPIOCEN
включает тактирование порта GPIOC.
RCC_AHB4ENR_GPIOCEN
— маска (константа), соответствующая конкретному биту регистра.

Она определена в заголовках ST, обычно что-то вроде
#define RCC_AHB4ENR_GPIOCEN (1U << 2)
(номер бита условен, точный можно посмотреть в RM0433).
Оператор
|=
:

x |= y;
означает
x = x | y;
(побитовое ИЛИ и запись обратно).
Это значит: «включи (установи в 1) те биты, которые стоят в 1 в маске
GPIOCEN
, не трогая остальные».
Зачем это нужно?
Любой модуль (GPIO, USART, FMC и т.д.) в STM32 должен иметь включённое тактирование.
Если не включить тактирование GPIOC:

регистры могут не работать,
доступ будет приводить к ошибкам шины,
или просто изменения не будут иметь эффекта.
2.3. Настраиваем PC13 как выход
В STM32 каждый пин настраивается через регистр
MODER
(
GPIOx_MODER
):

На каждый пин идут 2 бита:
00
— вход,
01
— общий выход,
10
— альтернативная функция,
11
— аналоговый.
У нас пин номер 13, значит его два бита — это:

биты номер 26 и 27 (13 * 2 и 13 * 2 + 1).
Сброс старого режима:
GPIOC->MODER &= ~(0x3U << (13 * 2));
Разбор:

GPIOC
— структура регистров порта C (как
RCC
, только для GPIO).

MODER
— регистр, задающий режимы пинов.

0x3U
— это число
3
в 16-ричной форме (0x3 = двоичное 11b).

(13 * 2)
— сдвиг на 26 бит (мы хотим попасть в пару битов для пина 13).

0x3U << (13 * 2)
— маска
11
сдвинутая в нужное место, пример:
... 00000011 000...
на позиции для пина 13.

~(...)
— побитовое НЕ. Из
000...0011
получается
111...1100
(с инверсией).

&=
— «и с присваиванием»:

x &= y;
значит
x = x & y;
.
Итого:

мы обнуляем два бита для пина 13,
не трогая остальные биты (другие пины).
Установка режима «выход»:
GPIOC->MODER |=  (0x1U << (13 * 2));
0x1U
— двоичное
01
.
0x1U << (13 * 2)
— маска, где только младший бит пары для пина 13 = 1, старший = 0.
|=
— устанавливаем этот бит в 1, второй остаётся 0.
Получаем:

два бита для PC13 =
01
→ общий цифровой выход.
2.4. Управляем светодиодом через регистр BSRR
В STM32 есть два способа изменить выходной уровень:

через
ODR
(Output Data Register),
через
BSRR
(Bit Set/Reset Register).
Мы используем
BSRR
, потому что он:

позволяет атомарно устанавливать и сбрасывать биты,
очень удобен для работы с отдельными пинами.
Зажечь светодиод
GPIOC->BSRR = (1U << (13 + 16)); // reset bit 13 (низкий уровень)
В
BSRR
младшие 16 бит (0..15) — это «set bits»:
запись
1
в бит
n
→ установить пин
n
в 1 (высокий уровень).
Старшие 16 бит (16..31) — это «reset bits»:
запись
1
в бит
n+16
→ сбросить пин
n
в 0 (низкий уровень).
(13 + 16)
= 29 → это бит «reset» для пина 13.

То есть:

мы записываем
1
в бит 29,
это приводит к тому, что на пине PC13 устанавливается 0.
Так как у тебя светодиод подтянут к 3.3В, скорее всего схема такая:

PC13 → светодиод → резистор → 3.3 В.
Значит:
когда PC13 = 1 → с обоих сторон светодиода почти одинаковый потенциал → не светит,
когда PC13 = 0 → через светодиод течёт ток к низкому уровню → светит.
Поэтому:

reset
(0) = зажечь.
Потушить светодиод
GPIOC->BSRR = (1U << 13); // set bit 13 (высокий уровень)
Здесь мы используем младшие 16 бит BSRR.
1U << 13
→ установка бита 13 в «set» части.
Это поднимает PC13 в 1 → светодиод гаснет.
2.5. Задержка
delay(1000000);
Вызываем нашу функцию задержки.
Почему
1000000
? Просто «примерно большая цифра», чтобы глазом было видно мигание.
На разных частотах ядра скорость будет разная; позже мы сделаем точные задержки через таймер (TIM6/TIM7 или SysTick/Freertos tick).
Дальше
Сейчас лучше остановиться на этом шаге и убедиться, что:

Ты:

вставил код в
main.c
,
понимаешь каждую строку (если нет — пожалуйста, спрашивай прямо по конкретной строке),
собрал и залил проект.
На плате:

светодиод PC13 мигает (или хотя бы меняет состояние; если инвертировано — легко поменяем местами включение/выключение).
Вопросы к тебе
Собрался ли проект с этим кодом без ошибок?
Мигает ли светодиод как ожидается?
Есть ли строки, которые до конца непонятны (например, почему именно
13*2
, зачем
~
, зачем
volatile
и т.д.)?
Когда ты скажешь, что с этим разобрался, следующим шагом предлагаю:

разобрать, как устроен
SystemCoreClock
и тактирование по умолчанию;
а потом начать USART1 на PA9/PA10: сначала простейшая функция
USART1_SendChar
, и разберём регистры
USART1->BRR
,
USART1->TDR
, флаги
TXE
,
TC
и т.д.


регистр BSRR не устанавливается и не сбрасывается. Возможно что то забыли включить. Проект компилируется без ошибок.

Хорошо, что ты это проверил и написал. Раз проект собирается, но светодиод не реагирует, разбираем спокойно и по шагам, почему
BSRR
«не работает».

Скорее всего, проблема в одном из трёх мест:

Тактирование GPIOC не включено (или включается не тем способом / не в то время).
Пин PC13 не настроен как выход (MODER остался входом или альтернативой).
Аппаратная особенность платы: светодиод реально не на PC13 (или активен наоборот).
Пойдём по порядку и немного усилим код диагностикой.

1. Убедимся, что реально включили тактирование GPIOC
Строка:

RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;
должна включить тактирование. Давай добавим проверку (и заодно убедимся, что код точно выполняется):

#include "stm32h7xx.h"

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}

int main(void)
{
    // 1. Включаем тактирование порта C
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

    // Небольшая "защита от дурака": читаем обратно регистр и убеждаемся, что бит установлен
    if ((RCC->AHB4ENR & RCC_AHB4ENR_GPIOCEN) == 0)
    {
        // Если сюда попадём — что-то совсем странно (но это маловероятно)
        while (1)
        {
            // Висим тут
        }
    }

    // 2. Настраиваем PC13 как выход
    GPIOC->MODER &= ~(0x3U << (13 * 2));
    GPIOC->MODER |=  (0x1U << (13 * 2));

    while (1)
    {
        // Зажечь (низкий уровень на пине)
        GPIOC->BSRR = (1U << (13 + 16));
        delay(1000000);

        // Потушить (высокий уровень на пине)
        GPIOC->BSRR = (1U << 13);
        delay(1000000);
    }
}
Что важно проверить:

В отладчике Keil (Debug):

Поставь breakpoint на строку с
RCC->AHB4ENR |= ...;
.
Выполни её (Step Over).
Открой окно Watch или Memory:
Добавь в Watch выражение
RCC->AHB4ENR
.
Убедись, что бит
GPIOCEN
там = 1 (обычно это бит 2, но точное положение можно посмотреть в RM0433 и заголовках).
Затем перейди к строке с
GPIOC->MODER &= ...
:

После выполнения двух строк настройки MODER открой
GPIOC->MODER
в Watch.
Посмотри, какие биты у пина 13 (бит 26 и 27):
Должно быть
01
(значит выход).
Если хочешь, я могу объяснить, как именно это посмотреть в Keil (что открыть, куда кликнуть).

2. Проверим, что код точно выполняется (мигание задержкой)
Иногда бывает так:

В
SystemInit()
или в startup что-то перенастраивает порты,
или код вообще не доходит до
main
(например, попадает в HardFault).
Чтобы убедиться, что цикл в
while(1)
реально живой, давай добавим «тупой» счётчик в памяти, который можно смотреть в отладчике:

#include "stm32h7xx.h"

volatile uint32_t debug_counter = 0;

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}

int main(void)
{
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

    GPIOC->MODER &= ~(0x3U << (13 * 2));
    GPIOC->MODER |=  (0x1U << (13 * 2));

    while (1)
    {
        debug_counter++;  // Увеличиваем счётчик в каждом цикле

        GPIOC->BSRR = (1U << (13 + 16));
        delay(100000);

        GPIOC->BSRR = (1U << 13);
        delay(100000);
    }
}
volatile uint32_t debug_counter = 0;
volatile
, чтобы компилятор не оптимизировал переменную.
В отладчике добавь
debug_counter
в Watch и посмотри — растёт ли число.
Если растёт → цикл точно выполняется.
Если
debug_counter
растёт, а светодиод не мигает — значит проблема либо в настройке пина, либо в аппаратной части (светодиод не там, где мы думаем).

3. Очень частый момент: PC13 на STM32H7
У «классических» STM32F1/F4 PC13 часто используется для кнопки/светодиода.
У STM32H7 и кастомных китайских плат:

PC13 может быть свободным, а светодиод может висеть на другом пине (например, PA5, PB0 и т.д.),
или светодиод может быть подключён так, что его трудно увидеть (слишком маленький резистор, наоборот активен).
Чтобы убедиться, что именно PC13 меняет уровень, сделаем ещё один шаг — будем читать регистр ODR:

uint32_t odr_value;

while (1)
{
    GPIOC->BSRR = (1U << (13 + 16)); // 0 на PC13
    odr_value = GPIOC->ODR;          // читаем выходной регистр
    delay(100000);

    GPIOC->BSRR = (1U << 13);        // 1 на PC13
    odr_value = GPIOC->ODR;
    delay(100000);
}
В отладчике смотри
odr_value
или прямо
GPIOC->ODR
:
Бит 13 должен меняться: 0 → 1 → 0 → 1 → …
Если бит 13 в ODR меняется, но светодиод не мигает — значит светодиод не на этом пине или схема активная другая.

4. Важный момент: не мешает ли что-то из
SystemInit
или других файлов?
Так как ты создавал проект через Keil с CMSIS, у тебя, скорее всего, есть файл
system_stm32h7xx.c
.
Там в
SystemInit()
могут быть:

включения кэшей,
базовая настройка тактирования,
иногда — настройка некоторых пинов (редко, но бывает, если проект был сгенерирован чем‑то ещё).
Чтобы исключить стороннее вмешательство, можно на время закомментировать/упростить
SystemInit
(если ты уже там много менял), но я бы сначала просто посмотрел код
SystemInit()
и убедился, что там:

НЕ перенастраиваются GPIOC или RCC->AHB4ENR после нашего кода,
нет странной инициализации.
Если хочешь, можешь скопировать сюда содержимое твоего
SystemInit()
(или хотя бы его тело), и я скажу, есть ли там что‑то подозрительное.

Давай проверим пошагово
Чтобы не распыляться, сделай, пожалуйста, так:

Возьми вот этот минимальный
main.c
:
#include "stm32h7xx.h"

volatile uint32_t debug_counter = 0;

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}

int main(void)
{
    // Включаем тактирование порта C
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

    // Настраиваем PC13 как выход
    GPIOC->MODER &= ~(0x3U << (13 * 2));
    GPIOC->MODER |=  (0x1U << (13 * 2));

    while (1)
    {
        debug_counter++;

        // 0 на PC13
        GPIOC->BSRR = (1U << (13 + 16));
        delay(100000);

        // 1 на PC13
        GPIOC->BSRR = (1U << 13);
        delay(100000);
    }
}
Запусти отладчик в Keil:
Убедись, что
debug_counter
растёт.
Посмотри
RCC->AHB4ENR
— установлен ли бит для GPIOC.
Посмотри
GPIOC->MODER
— действительно ли биты 26–27 = 01.
Посмотри
GPIOC->ODR
— меняется ли бит 13.
Напиши, пожалуйста:

растёт ли
debug_counter
;
меняется ли бит 13 в
GPIOC->ODR
(0/1);
и мигает ли при этом светодиод.
От этого дальше будем отталкиваться:

если регистры меняются — будем разбираться с реальным пином светодиода;
если регистры не меняются — углубимся в RCC / SystemInit.


м /*

main.c Board STM32H7_CORE
03.01.2026 */
/* Includes */ #include "stm32h7xx.h"

/* Function prototypes */

/* Function prototypes END */

/* USER CODE 0 / static void delay(volatile uint32_t count) { while (count--) { __NOP(); // "Ничего не делать" — одна пустая инструкция } } / USER CODE END 0 */

int main(void) { // 1. Включаем тактирование порта C RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

// 2. Настраиваем PC13 как "общий выход" (General purpose output)
// Сначала очищаем нужные биты MODER для PC13
GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk;
// Потом записываем туда 01b (output)
GPIOC->MODER |= GPIO_MODER_MODE13_0 ;
while(1)
{
    // 3. Зажечь светодиод (скорее всего, "0" на пине = светит)
    GPIOC->BSRR = (1 << GPIO_BSRR_BR13_Pos);   // reset bit 13 (низкий уровень)

    delay(1);
    
    GPIOC->BSRR |=  GPIO_BSRR_BR13_Msk  ; // reset bit 13 (низкий уровень)
    
    delay(1);
}        
}

/* main.c END */

Отлично, ты уже аккуратно пользуешься масками из CMSIS — это правильно.
Разберём, что сейчас не так, построчно, и сразу поправим, чтобы увидеть реальное мигание.

1. Разбор твоего кода
Твой
main.c
:

#include "stm32h7xx.h"

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP(); // "Ничего не делать" — одна пустая инструкция
    }
}

int main(void)
{
    // 1. Включаем тактирование порта C
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

    // 2. Настраиваем PC13 как "общий выход" (General purpose output)
    // Сначала очищаем нужные биты MODER для PC13
    GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk;
    // Потом записываем туда 01b (output)
    GPIOC->MODER |= GPIO_MODER_MODE13_0 ;

    while(1)
    {
        // 3. Зажечь светодиод (скорее всего, "0" на пине = светит)
        GPIOC->BSRR = (1 << GPIO_BSRR_BR13_Pos);   // reset bit 13 (низкий уровень)

        delay(1);
        
        GPIOC->BSRR |=  GPIO_BSRR_BR13_Msk  ; // reset bit 13 (низкий уровень)
        
        delay(1);
    }        
}
1.1. Настройка MODER — сделана корректно
GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk;
GPIOC->MODER |= GPIO_MODER_MODE13_0;
GPIO_MODER_MODE13_Msk
— маска для двух битов режима пина 13.
~...
и
&=
— очищаем эти 2 бита (делаем 00).
GPIO_MODER_MODE13_0
— это значение
01b
для этих двух битов → «общий выход».
Здесь всё хорошо.

1.2. Ошибка в работе с BSRR
Вот эта часть:

GPIOC->BSRR = (1 << GPIO_BSRR_BR13_Pos);   // reset bit 13 (низкий уровень)
delay(1);
GPIOC->BSRR |=  GPIO_BSRR_BR13_Msk  ;      // reset bit 13 (низкий уровень)
delay(1);
Проблемы:

Обе строки фактически делают reset (устанавливают 0 на пине), а не set/reset попеременно:
GPIO_BSRR_BR13_Pos
— позиция бита reset для пина 13 (то есть 13+16).
1 << GPIO_BSRR_BR13_Pos
— это маска «сбросить пин 13» (установить 0).
GPIO_BSRR_BR13_Msk
— маска того же бита/битов reset (тоже для сброса).
То есть ты два раза подряд сбрасываешь (0), ни разу не устанавливаешь (1).
Поэтому пин всегда остаётся в 0 (если до этого был 1) — или вообще не меняется, если уже был 0.

Для установки (1) пина нужно использовать SET-бит, а не BR (bit reset).
Для пина 13:
Установить 1: записать
1
в бит
BS13
(в младших 16 битах BSRR).
Сбросить 0: записать
1
в бит
BR13
(в старших 16 битах BSRR).
В CMSIS это обычно:

GPIO_BSRR_BS13
или
GPIO_BSRR_BS13_Msk
— set.
GPIO_BSRR_BR13
или
GPIO_BSRR_BR13_Msk
— reset.
2. Правильный вариант мигания с использованием масок CMSIS
Давай напишем так, чтобы было максимально читабельно и по смыслу:

#include "stm32h7xx.h"

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}

int main(void)
{
    // 1. Включаем тактирование порта C
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

    // 2. Настраиваем PC13 как "общий выход"
    GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk; // очищаем 2 бита
    GPIOC->MODER |=  GPIO_MODER_MODE13_0;   // устанавливаем 01b = output

    while (1)
    {
        // Зажечь светодиод (если 0 = включено)
        GPIOC->BSRR = GPIO_BSRR_BR13;  // BR13 = сбросить пин 13 в 0
        delay(1000000);

        // Потушить светодиод (1 = выключено)
        GPIOC->BSRR = GPIO_BSRR_BS13;  // BS13 = установить пин 13 в 1
        delay(1000000);
    }
}
Пояснения по константам:

GPIO_BSRR_BR13
— это макрос конкретного бита reset:
аналогично
1U << GPIO_BSRR_BR13_Pos
.
запись этого значения в
BSRR
сбрасывает пин 13 (0 на пине).
GPIO_BSRR_BS13
— макрос для бита set:
аналогично
1U << GPIO_BSRR_BS13_Pos
.
запись этого значения в
BSRR
устанавливает пин 13 (1 на пине).
Обрати внимание:

В первой строке цикла мы делаем
=
, а не
|=
:
GPIOC->BSRR = GPIO_BSRR_BR13;
В данном случае нет смысла делать
|=
— регистра BSRR «одноразовый», его содержимое не «хранится», он просто воспринимает биты как команды.
3. Почему раньше «не срабатывало»
Ты дважды писал reset (BR), не писав ни разу set (BS).
Плюс, использование
|=
с BSRR может вводить в заблуждение:
BSRR
не надо «накапливать», каждое присваивание — это отдельная команда.
4. Что сейчас сделать тебе
Замени цикл
while(1)
в своём
main.c
на вот такой:
while (1)
{
    GPIOC->BSRR = GPIO_BSRR_BR13;  // 0 на пине
    delay(1000000);

    GPIOC->BSRR = GPIO_BSRR_BS13;  // 1 на пине
    delay(1000000);
}
Собери и прошей проект.

Если светодиод:

мигает — отлично, значит и тактирование, и MODER, и BSRR работают.
не мигает — в отладчике:
проверь
GPIOC->ODR
— меняется ли бит 13;
если меняется, но светодиод не реагирует — скорее всего физически светодиод не на PC13.
5. Вопросы к тебе
После этой правки светодиод начал мигать?
Хочешь, чтобы я отдельно разложил по полочкам, как именно CMSIS определяет:
GPIO_MODER_MODE13_Msk
,
GPIO_MODER_MODE13_0
,
GPIO_BSRR_BR13
,
GPIO_BSRR_BS13

(то есть откуда берутся эти макросы, что внутри и как связаны с Reference Manual)?
Когда с GPIO станет понятно, следующим шагом логично перейти к USART1 на PA9/PA10 в таком же стиле:
сначала включим тактирование, настроим пины в альтернативный режим, запишем Baudrate в
BRR
, а потом напишем простую
USART1_SendChar
и разберём каждый флаг.



/****************** Bits definition for GPIO_BSRR register *****************/ #define GPIO_BSRR_BS0_Pos (0U) #define GPIO_BSRR_BS0_Msk (0x1UL << GPIO_BSRR_BS0_Pos) /!< 0x00000001 / #define GPIO_BSRR_BS0 GPIO_BSRR_BS0_Msk #define GPIO_BSRR_BS1_Pos (1U) #define GPIO_BSRR_BS1_Msk (0x1UL << GPIO_BSRR_BS1_Pos) /!< 0x00000002 / #define GPIO_BSRR_BS1 GPIO_BSRR_BS1_Msk #define GPIO_BSRR_BS2_Pos (2U) #define GPIO_BSRR_BS2_Msk (0x1UL << GPIO_BSRR_BS2_Pos) /!< 0x00000004 / #define GPIO_BSRR_BS2 GPIO_BSRR_BS2_Msk #define GPIO_BSRR_BS3_Pos (3U) #define GPIO_BSRR_BS3_Msk (0x1UL << GPIO_BSRR_BS3_Pos) /!< 0x00000008 / #define GPIO_BSRR_BS3 GPIO_BSRR_BS3_Msk #define GPIO_BSRR_BS4_Pos (4U) #define GPIO_BSRR_BS4_Msk (0x1UL << GPIO_BSRR_BS4_Pos) /!< 0x00000010 / #define GPIO_BSRR_BS4 GPIO_BSRR_BS4_Msk #define GPIO_BSRR_BS5_Pos (5U) #define GPIO_BSRR_BS5_Msk (0x1UL << GPIO_BSRR_BS5_Pos) /!< 0x00000020 / #define GPIO_BSRR_BS5 GPIO_BSRR_BS5_Msk #define GPIO_BSRR_BS6_Pos (6U) #define GPIO_BSRR_BS6_Msk (0x1UL << GPIO_BSRR_BS6_Pos) /!< 0x00000040 / #define GPIO_BSRR_BS6 GPIO_BSRR_BS6_Msk #define GPIO_BSRR_BS7_Pos (7U) #define GPIO_BSRR_BS7_Msk (0x1UL << GPIO_BSRR_BS7_Pos) /!< 0x00000080 / #define GPIO_BSRR_BS7 GPIO_BSRR_BS7_Msk #define GPIO_BSRR_BS8_Pos (8U) #define GPIO_BSRR_BS8_Msk (0x1UL << GPIO_BSRR_BS8_Pos) /!< 0x00000100 / #define GPIO_BSRR_BS8 GPIO_BSRR_BS8_Msk #define GPIO_BSRR_BS9_Pos (9U) #define GPIO_BSRR_BS9_Msk (0x1UL << GPIO_BSRR_BS9_Pos) /!< 0x00000200 / #define GPIO_BSRR_BS9 GPIO_BSRR_BS9_Msk #define GPIO_BSRR_BS10_Pos (10U) #define GPIO_BSRR_BS10_Msk (0x1UL << GPIO_BSRR_BS10_Pos) /!< 0x00000400 / #define GPIO_BSRR_BS10 GPIO_BSRR_BS10_Msk #define GPIO_BSRR_BS11_Pos (11U) #define GPIO_BSRR_BS11_Msk (0x1UL << GPIO_BSRR_BS11_Pos) /!< 0x00000800 / #define GPIO_BSRR_BS11 GPIO_BSRR_BS11_Msk #define GPIO_BSRR_BS12_Pos (12U) #define GPIO_BSRR_BS12_Msk (0x1UL << GPIO_BSRR_BS12_Pos) /!< 0x00001000 / #define GPIO_BSRR_BS12 GPIO_BSRR_BS12_Msk #define GPIO_BSRR_BS13_Pos (13U) #define GPIO_BSRR_BS13_Msk (0x1UL << GPIO_BSRR_BS13_Pos) /!< 0x00002000 / #define GPIO_BSRR_BS13 GPIO_BSRR_BS13_Msk #define GPIO_BSRR_BS14_Pos (14U) #define GPIO_BSRR_BS14_Msk (0x1UL << GPIO_BSRR_BS14_Pos) /!< 0x00004000 / #define GPIO_BSRR_BS14 GPIO_BSRR_BS14_Msk #define GPIO_BSRR_BS15_Pos (15U) #define GPIO_BSRR_BS15_Msk (0x1UL << GPIO_BSRR_BS15_Pos) /!< 0x00008000 / #define GPIO_BSRR_BS15 GPIO_BSRR_BS15_Msk #define GPIO_BSRR_BR0_Pos (16U) #define GPIO_BSRR_BR0_Msk (0x1UL << GPIO_BSRR_BR0_Pos) /!< 0x00010000 / #define GPIO_BSRR_BR0 GPIO_BSRR_BR0_Msk #define GPIO_BSRR_BR1_Pos (17U) #define GPIO_BSRR_BR1_Msk (0x1UL << GPIO_BSRR_BR1_Pos) /!< 0x00020000 / #define GPIO_BSRR_BR1 GPIO_BSRR_BR1_Msk #define GPIO_BSRR_BR2_Pos (18U) #define GPIO_BSRR_BR2_Msk (0x1UL << GPIO_BSRR_BR2_Pos) /!< 0x00040000 / #define GPIO_BSRR_BR2 GPIO_BSRR_BR2_Msk #define GPIO_BSRR_BR3_Pos (19U) #define GPIO_BSRR_BR3_Msk (0x1UL << GPIO_BSRR_BR3_Pos) /!< 0x00080000 / #define GPIO_BSRR_BR3 GPIO_BSRR_BR3_Msk #define GPIO_BSRR_BR4_Pos (20U) #define GPIO_BSRR_BR4_Msk (0x1UL << GPIO_BSRR_BR4_Pos) /!< 0x00100000 / #define GPIO_BSRR_BR4 GPIO_BSRR_BR4_Msk #define GPIO_BSRR_BR5_Pos (21U) #define GPIO_BSRR_BR5_Msk (0x1UL << GPIO_BSRR_BR5_Pos) /!< 0x00200000 / #define GPIO_BSRR_BR5 GPIO_BSRR_BR5_Msk #define GPIO_BSRR_BR6_Pos (22U) #define GPIO_BSRR_BR6_Msk (0x1UL << GPIO_BSRR_BR6_Pos) /!< 0x00400000 / #define GPIO_BSRR_BR6 GPIO_BSRR_BR6_Msk #define GPIO_BSRR_BR7_Pos (23U) #define GPIO_BSRR_BR7_Msk (0x1UL << GPIO_BSRR_BR7_Pos) /!< 0x00800000 / #define GPIO_BSRR_BR7 GPIO_BSRR_BR7_Msk #define GPIO_BSRR_BR8_Pos (24U) #define GPIO_BSRR_BR8_Msk (0x1UL << GPIO_BSRR_BR8_Pos) /!< 0x01000000 / #define GPIO_BSRR_BR8 GPIO_BSRR_BR8_Msk #define GPIO_BSRR_BR9_Pos (25U) #define GPIO_BSRR_BR9_Msk (0x1UL << GPIO_BSRR_BR9_Pos) /!< 0x02000000 / #define GPIO_BSRR_BR9 GPIO_BSRR_BR9_Msk #define GPIO_BSRR_BR10_Pos (26U) #define GPIO_BSRR_BR10_Msk (0x1UL << GPIO_BSRR_BR10_Pos) /!< 0x04000000 / #define GPIO_BSRR_BR10 GPIO_BSRR_BR10_Msk #define GPIO_BSRR_BR11_Pos (27U) #define GPIO_BSRR_BR11_Msk (0x1UL << GPIO_BSRR_BR11_Pos) /!< 0x08000000 / #define GPIO_BSRR_BR11 GPIO_BSRR_BR11_Msk #define GPIO_BSRR_BR12_Pos (28U) #define GPIO_BSRR_BR12_Msk (0x1UL << GPIO_BSRR_BR12_Pos) /!< 0x10000000 / #define GPIO_BSRR_BR12 GPIO_BSRR_BR12_Msk #define GPIO_BSRR_BR13_Pos (29U) #define GPIO_BSRR_BR13_Msk (0x1UL << GPIO_BSRR_BR13_Pos) /!< 0x20000000 / #define GPIO_BSRR_BR13 GPIO_BSRR_BR13_Msk #define GPIO_BSRR_BR14_Pos (30U) #define GPIO_BSRR_BR14_Msk (0x1UL << GPIO_BSRR_BR14_Pos) /!< 0x40000000 / #define GPIO_BSRR_BR14 GPIO_BSRR_BR14_Msk #define GPIO_BSRR_BR15_Pos (31U) #define GPIO_BSRR_BR15_Msk (0x1UL << GPIO_BSRR_BR15_Pos) /!< 0x80000000 */ #define GPIO_BSRR_BR15 GPIO_BSRR_BR15_Msk

Отлично, ты как раз прислал тот фрагмент, на который я опирался. Давай свяжем его с тем, что мы делаем в
main.c
, и аккуратно поправим код.

1. Как читать эти макросы для BSRR
Из твоего фрагмента:

GPIO_BSRR_BS13_Pos  = 13

GPIO_BSRR_BS13_Msk  = (0x1UL << 13)
→ бит 13 (set, установить 1)

GPIO_BSRR_BS13      = GPIO_BSRR_BS13_Msk

GPIO_BSRR_BR13_Pos  = 29
(13 + 16)

GPIO_BSRR_BR13_Msk  = (0x1UL << 29)
→ бит 29 (reset, установить 0)

GPIO_BSRR_BR13      = GPIO_BSRR_BR13_Msk

Важно:

BSx (bit set) — младшие 16 бит, запись 1 → пин x = 1 (высокий уровень).
BRx (bit reset) — старшие 16 бит, запись 1 → пин x = 0 (низкий уровень).
Поэтому:

GPIOC->BSRR = GPIO_BSRR_BS13;
→ PC13 = 1
GPIOC->BSRR = GPIO_BSRR_BR13;
→ PC13 = 0
2. Исправляем твой
while(1)
так, чтобы был set и reset
Сейчас у тебя фактически два раза подряд reset (через BR13_Pos и BR13_Msk).
Нужно сделать чередование:

while (1)
{
    // Зажечь (если 0 = светит)
    GPIOC->BSRR = GPIO_BSRR_BR13;  // записываем маску reset для пина 13
    delay(1000000);

    // Потушить (если 1 = не светит)
    GPIOC->BSRR = GPIO_BSRR_BS13;  // записываем маску set для пина 13
    delay(1000000);
}
Полный
main.c
сейчас может выглядеть так:

#include "stm32h7xx.h"

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}

int main(void)
{
    // 1. Включаем тактирование порта C
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

    // 2. Настраиваем PC13 как "общий выход"
    GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk; // очищаем 2 бита для пина 13
    GPIOC->MODER |=  GPIO_MODER_MODE13_0;   // ставим 01b: general purpose output

    while (1)
    {
        // 3. Зажечь светодиод (предполагаем, что 0 = включен)
        GPIOC->BSRR = GPIO_BSRR_BR13;  // PC13 = 0
        delay(1000000);

        // 4. Потушить светодиод (1 = выключен)
        GPIOC->BSRR = GPIO_BSRR_BS13;  // PC13 = 1
        delay(1000000);
    }
}
Обрати внимание на моменты:

В
BSRR
лучше использовать оператор
=
, а не
|=
, потому что:
это «регист команд», а не «хранимое состояние»;
каждый раз, когда ты пишешь туда значение, оно интерпретируется как команда set/reset для соответствующих пинов.
GPIO_BSRR_BR13
и
GPIO_BSRR_BS13
— уже готовые маски, их не нужно ещё раз сдвигать.
3. Что сейчас проверить в отладчике
После этой правки:

Собери и прошей проект.
Включи отладчик и:
добавь в Watch:
RCC->AHB4ENR
(убедись, что бит GPIOCEN = 1),
GPIOC->MODER
(биты 26–27 = 01),
GPIOC->ODR
(бит 13 должен менять 0/1 в такт нашим записям в BSRR).
Посмотри на плату — мигает ли фактический светодиод.
4. Если светодиод всё ещё не мигает
Тогда у нас два варианта:

ODR меняется, а светодиод нет → почти наверняка светодиод физически не на PC13
(или подключен иначе — к VSS, или через транзистор и т.п.).

ODR не меняется → значит:

либо не настроен MODER (не выход),
либо тактирование GPIOC не включено,
либо есть переопределение где‑то ещё (например, в
SystemInit
или другом месте).
В этом случае можно сделать ещё один маленький шаг:
посмотреть в схеме/даташите платы, на какой реально пин выведен LED. Если у тебя есть PDF/фото схемы — можешь прислать фрагмент с LED, я помогу прочитать.

Напиши, пожалуйста:

Что получилось после замены на
GPIO_BSRR_BR13
/
GPIO_BSRR_BS13
?
Меняется ли бит 13 в
GPIOC->ODR
в отладчике?


Светодиод мигает примерно раз в секунду. вот код: /* USER CODE 0 / static void delay(volatile uint32_t count) { while (count--) { __NOP(); // "Ничего не делать" — одна пустая инструкция } } / USER CODE END 0 */

int main(void) { // 1. Включаем тактирование порта C RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;

// 2. Настраиваем PC13 как "общий выход" (General purpose output)
// Сначала очищаем нужные биты MODER для PC13
GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk;
// Потом записываем туда 01b (output)
GPIOC->MODER |= GPIO_MODER_MODE13_0 ;
while(1)
{
    // 3. Зажечь светодиод (скорее всего, "0" на пине = светит)
    GPIOC->BSRR =  GPIO_BSRR_BR13;   // reset bit 13 (низкий уровень)

    delay(10000000);
    
    GPIOC->BSRR =  GPIO_BSRR_BS13  ; // reset bit 13 (низкий уровень)
    
    delay(10000000);
}        
}

/* main.c END */

Отличный результат: светодиод мигает — значит ты:

правильно включил тактирование GPIOC,
настроил MODER для PC13 как выход,
научился пользоваться BSRR (BS/BR),
видишь реальный эффект на железе.
Это очень важный базовый шаг.

Дальше логично двигаться так же по шагам и с пониманием.

Коротко разберём твой финальный код ещё раз (закрепление)
static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}
volatile
защищает от оптимизации — цикл точно выполнится нужное число раз.
__NOP()
гарантирует, что внутри цикла есть реальная инструкция.
RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;
Включил тактирование порта C (AHB4 шина, бит GPIOCEN).
GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk;
GPIOC->MODER |=  GPIO_MODER_MODE13_0;
Очищаешь 2 бита режима для PC13, потом ставишь
01
→ общий цифровой выход.
GPIOC->BSRR = GPIO_BSRR_BR13; // PC13 = 0 → светодиод горит
delay(10000000);

GPIOC->BSRR = GPIO_BSRR_BS13; // PC13 = 1 → светодиод гаснет
delay(10000000);
Используешь:
BR13
— reset (0),
BS13
— set (1),
правильно, через оператор
=
(BSRR — это «регистратор команд», а не состояние).
Что предлагаю дальше (выбери сам)
Теперь у тебя есть «контроль» над GPIO. Следующие логичные шаги:

Вариант A: Понять, как МК приходит к
main
(startup / SystemInit)
Разобрать:
таблицу векторов,
Reset_Handler
,
инициализацию
.data
/
.bss
,
вызов
SystemInit()
и
main()
.
Понять, откуда берётся
SystemCoreClock
и какая частота сейчас реально стоит (мы пока используем стандартную после сброса).
Вариант B: Сделать USART1 на PA9/PA10 (через CH340E)
Пошагово:

Включим тактирование USART1 и GPIOA.

Настроим PA9 (TX) и PA10 (RX) в режим альтернативной функции (AF7 — USART1).

Зададим скорость, формат кадра в регистрах:

USART1->BRR
,
CR1
,
CR2
.
Напишем функцию:

void USART1_SendChar(char c);
и разберём:

флаг TXE (передаточный буфер пуст),
запись в регистр
TDR
,
флаг TC (передача завершена).
Потом сделаем
USART1_SendString(const char *s)
и отправим, например, строку
"Hello, STM32H7\r\n"
в терминал (PuTTY и т.п.).

Вариант C: Начать разбирать системное тактирование (RCC, PLL, частоты)
Сейчас мигание и задержка зависят от текущей частоты ядра (по умолчанию).
Можно:
посмотреть, какая у тебя исходная частота после сброса,
затем спланировать настройку PLL под твои цели (400 МГц для ядра, 50 МГц для USART, 160 МГц для FMC, 25 МГц для LTDC и т.д.),
но это уже более сложный шаг, лучше делать, когда понятен USART и отладочный вывод.
На твоём месте, с учётом, что проект будет сложным (FreeRTOS, SDRAM, LTDC, QSPI), я бы выбрал:

Следующим шагом сделать USART1 с выводом текста, чтобы:

можно было видеть в терминале отладочные сообщения,
дальше все сложные шаги (RCC, SDRAM, QSPI) сопровождать выводом:
«Включил PLL1…», «Инициализация SDRAM начата…», «Ошибка теста SDRAM…» и т.д.
Так мы будем видеть, до какого места программа дошла, и легче будет диагностировать ошибки.

Если тебе это подходит, напиши:

Давай USART1

и мы начнём с первой строки кода для USART1 — включения тактирования, и подробно разберём, что такое APB2, PCLK2, откуда берётся частота для USART и как она связана с
BRR
и скоростью, например 115200 бод.



Давай начнем с UART. Но возникает вопрос, UART требует тактирование ядра, установки прескаллеров . То есть пока мы не настроим RCC , UART не сможет работать. Или я ошибаюсь?

Ты мыслишь абсолютно правильно: любой периферийный модуль (включая USART) зависит от тактирования.
Но здесь есть важный нюанс:

После сброса контроллер уже имеет какое‑то базовое тактирование, которое задаёт заводская логика (HSI, дефолтные делители и т.п.).
На этом «дефолтном» тактировании USART уже может работать, просто:
частота шины PCLK2 будет не та, что ты хочешь в финальном проекте,
значения в
BRR
для нужного baudrate будут другими.
То есть:

Для обучения и первых шагов мы можем пользоваться тем, что даёт MCU «из коробки» — не трогая пока PLL и сложные настройки RCC.
Потом, когда будем настраивать RCC под твои целевые частоты (400 МГц ядро, 50 МГц USART и т.п.), мы:
изменим конфигурацию тактирования,
пересчитаем
BRR
для USART1 под новые частоты,
и поймём, как это делается.
Так что:

Да, USART требует тактирования (своего kernel clock, зависящего от RCC).
Но нам не обязательно сначала полностью настраивать PLL и всё дерево RCC, чтобы просто отправить текст в терминал.
Можно использовать «базовую» частоту, которая уже есть после сброса.
План для USART1 (PA9/PA10) на текущем этапе
Мы сделаем так:

Используем текущее (дефолтное) тактирование, не лезем пока в PLL.
Включим тактирование:
порта A (GPIOA),
USART1 (шина APB2).
Настроим PA9 и PA10 в режим альтернативной функции 7 (AF7) — это USART1_TX и USART1_RX.
Настроим USART1 на какую‑то стандартную скорость (115200 бод) исходя из текущей частоты PCLK2.
Здесь я покажу формулу и мы вместе разберём, откуда берётся значение в
BRR
.
Напишем функцию
USART1_Init()
и
USART1_SendChar()
/
USART1_SendString()
— и разберём каждую строку.
Шаг 0. Нам нужно знать стартовую частоту PCLK2
Для точного расчёта
BRR
нужно знать, какая сейчас частота:

системного такта (SYSCLK),
шины APB2 (PCLK2), от которой питается USART1.
У STM32H7 после сброса типично:

включен HSI (внутренний RC-генератор 64 МГц),
SYSCLK = HSI,
делители шин по умолчанию = 1 (или другие — нужно проверить в RM или в
system_stm32h7xx.c
).
В файле
system_stm32h7xx.c
есть переменная
SystemCoreClock
и код, который её задаёт по умолчанию.
Сейчас не будем глубоко копать — сделаем так:

Открой
system_stm32h7xx.c
.
Найди строку, где задаётся
SystemCoreClock
по умолчанию (обычно что‑то вроде
uint32_t SystemCoreClock = 64000000;
или другое значение).
Скажи мне это значение — мы будем использовать его как основу.
Пока что, чтобы двигаться дальше, я предположу, что у тебя:

SystemCoreClock
= 64 МГц,
PCLK2 = 64 МГц (делители = 1).
Если будет не так — мы просто подправим формулу и число.

Шаг 1. Включаем тактирование GPIOA и USART1
Добавим в
main.c
(пока рядом с кодом для светодиода; позже мы это вынесем в отдельные функции):

#include "stm32h7xx.h"

static void delay(volatile uint32_t count)
{
    while (count--)
    {
        __NOP();
    }
}

// Вперёд объявим прототипы
void USART1_Init(void);
void USART1_SendChar(char c);
void USART1_SendString(const char *s);

int main(void)
{
    // 1. Включаем тактирование порта C (для LED) и порта A (для USART1)
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN; // уже было
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN; // добавили GPIOA

    // 2. Настраиваем PC13 как выход (как раньше)
    GPIOC->MODER &= ~GPIO_MODER_MODE13_Msk;
    GPIOC->MODER |=  GPIO_MODER_MODE13_0;

    // 3. Инициализируем USART1
    USART1_Init();

    // 4. Отправим тестовую строку
    USART1_SendString("USART1 init done\r\n");

    while (1)
    {
        // Мигаем светодиодом, как раньше
        GPIOC->BSRR = GPIO_BSRR_BR13;
        delay(1000000);

        GPIOC->BSRR = GPIO_BSRR_BS13;
        delay(1000000);
    }
}
Разбор:

RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN;
Включаем тактирование порта A, чтобы пины PA9/PA10 работали (иначе их регистры будут «мёртвые»).
USART1_Init();
Мы сейчас напишем эту функцию отдельно и разберём её.
USART1_SendString("USART1 init done\r\n");
Передадим строку при старте, чтобы увидеть в терминале.
Шаг 2. Настройка USART1: пины и регистры
Теперь напишем реализацию
USART1_Init()
.

Добавь ниже
main
в
main.c
:

void USART1_Init(void)
{
    // 1. Включаем тактирование USART1 по шине APB2
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

    // 2. Настраиваем PA9 (TX) и PA10 (RX) в режим альтернативной функции AF7

    // 2.1. Сначала делаем их альтернативной функцией в MODER
    GPIOA->MODER &= ~(GPIO_MODER_MODE9_Msk | GPIO_MODER_MODE10_Msk);
    GPIOA->MODER |=  (GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1);
    // MODEy_1: бит 1 = 1, бит 0 = 0 → 10b = Alternate function

    // 2.2. Выбираем конкретную альтернативную функцию AF7 в AFRH
    // Для пина 9 и 10 используется AFRH (pins 8..15)
    GPIOA->AFR[1] &= ~((0xF << ((9 - 8) * 4)) | (0xF << ((10 - 8) * 4)));
    GPIOA->AFR[1] |=  ((7   << ((9 - 8) * 4)) | (7   << ((10 - 8) * 4)));
    // Здесь 7 = AF7 (USART1)

    // 3. Настраиваем параметры USART1:
    //    - Baudrate
    //    - 8N1 (8 бит данных, без чётности, 1 стоп-бит)
    //    - включаем TX и RX, включаем сам USART

    // Предположим, что тактирование PCLK2 = 64 МГц (уточним позже из SystemCoreClock)
    uint32_t pclk2 = 64000000U;
    uint32_t baudrate = 115200U;
    uint32_t usartdiv = (pclk2 + (baudrate / 2U)) / baudrate; // округление

    USART1->BRR = usartdiv;

    // CR1: включаем USART, TX и RX
    USART1->CR1 = 0;                 // сначала сбросим всё
    USART1->CR1 |= USART_CR1_TE;     // разрешаем передатчик
    USART1->CR1 |= USART_CR1_RE;     // разрешаем приёмник
    USART1->CR1 |= USART_CR1_UE;     // включаем USART
}
Давай разберём это построчно и по смыслу.

2.1. Тактирование USART1
RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
RCC->APB2ENR
— регистр включения тактирования для модулей на шине APB2.
USART1EN
— бит, включающий тактирование USART1.
Пока этот бит = 0, все регистры USART1 либо «висят», либо не работают как надо.
Это аналогично включению GPIOC/GPIOA, только другая шина (APB2, а не AHB4).

2.2. MODER: альтернативная функция для PA9 и PA10
GPIOA->MODER &= ~(GPIO_MODER_MODE9_Msk | GPIO_MODER_MODE10_Msk);
GPIOA->MODER |=  (GPIO_MODER_MODE9_1   | GPIO_MODER_MODE10_1);
GPIO_MODER_MODE9_Msk
— маска для двух битов режима PA9.
GPIO_MODER_MODE10_Msk
— маска для двух битов режима PA10.
Мы:
сначала очищаем их (ставим 00),
затем устанавливаем только бит
_1
(то есть 10b).
Кодировка MODER для пина:

00
— вход,
01
— выход,
10
— альтернативная функция (AF),
11
— аналоговый.
MODE9_1
и
MODE10_1
включают режим
10
→ AF.

2.3. AFR: выбор конкретной альтернативы AF7
GPIOA->AFR[1] &= ~((0xF << ((9 - 8) * 4)) | (0xF << ((10 - 8) * 4)));
GPIOA->AFR[1] |=  ((7   << ((9 - 8) * 4)) | (7   << ((10 - 8) * 4)));
AFR[0]
— альтернативные функции для пинов 0..7.
AFR[1]
— для пинов 8..15.
Каждый пин получает 4 бита (от 0 до 15 → AF0..AF15).
Для пина 9:

индекс внутри AFR[1] =
9 - 8 = 1
,
его 4 бита — это биты [7:4] регистра AFR[1],
маска для него:
0xF << (1 * 4)
.
Для пина 10:

индекс =
10 - 8 = 2
,
его 4 бита — [11:8],
маска:
0xF << (2 * 4)
.
Сначала:

&= ~
очищаем эти 8 бит (2 пина × 4 бита).
Потом:

|= (7 << (...))
ставим значение
7
= AF7 (USART1).
Это как сказать: «сделай PA9 и PA10 альтернативной функцией номер 7».

2.4. Расчёт baudrate и запись в BRR
uint32_t pclk2 = 64000000U;
uint32_t baudrate = 115200U;
uint32_t usartdiv = (pclk2 + (baudrate / 2U)) / baudrate;

USART1->BRR = usartdiv;
Смысл:

Для обычного режима USART (без oversampling на 8 и т.п.) формула:

[ USARTDIV = \frac{f_{PCLK}}{\text{BaudRate}} ]

где:

f_PCLK
— частота шины, от которой кормится USART (PCLK2),
BaudRate — желаемая скорость (например, 115200).
Мы делаем:

usartdiv = (pclk2 + (baudrate / 2U)) / baudrate;
Это способ округлить результат к ближайшему целому:

добавляем половину делителя перед делением.
Пример, если PCLK2 = 64 МГц:

64000000 / 115200 ≈ 555.55
С округлением мы получим 556:
usartdiv = (64000000 + 57600) / 115200 ≈ 556
.
Записав
556
в
BRR
, мы получаем реальную скорость, чуть отличающуюся от 115200, но в пределах допустимого для UART.

Потом, когда мы точно узнаем PCLK2 (из реальной настройки RCC), мы пересчитаем это честно.

2.5. Настройка CR1: включаем USART, TX, RX
USART1->CR1 = 0;             // сбрасываем настройки
USART1->CR1 |= USART_CR1_TE; // включаем передатчик
USART1->CR1 |= USART_CR1_RE; // включаем приёмник
USART1->CR1 |= USART_CR1_UE; // включаем USART
CR1
— основной управляющий регистр USART.
По умолчанию:
8 бит данных,
без чётности,
1 стоп-бит (эти настройки в других полях CR1/CR2, мы пока их не трогаем → остаются дефолтными).
UE
— USART Enable.
TE
— Transmitter Enable.
RE
— Receiver Enable.
Пока мы будем использовать только передачу (TX).

Шаг 3. Реализуем
USART1_SendChar
и
USART1_SendString
Добавь в
main.c
:

void USART1_SendChar(char c)
{
    // Ждём, пока передаточный регистр будет пуст (TXE или TXE_TXFNF флаг)
    while ((USART1->ISR & USART_ISR_TXE_TXFNF) == 0)
    {
        // ждём
    }

    // Пишем символ в регистр передачи
    USART1->TDR = (uint8_t)c;
}

void USART1_SendString(const char *s)
{
    while (*s)
    {
        USART1_SendChar(*s);
        s++;
    }
}
Разбор:

USART1->ISR
— регистр статуса (Interrupt & Status Register).
USART_ISR_TXE_TXFNF
— флаг «передаточный регистр пуст / TX FIFO not full».
Пока он = 0 — регистр занят, нельзя писать новый байт.
Когда он = 1 — можем писать следующий символ в
TDR
.
USART1->TDR
— Transmit Data Register:
запись туда запускает отправку байта по TX.
В
USART1_SendString
:

Пока
*s
не равно
'\0'
(конец строки), отправляем каждый символ.
Что сделать сейчас
Добавь в
main.c
:

USART1_Init
,
USART1_SendChar
,
USART1_SendString
,
и вызов
USART1_SendString("USART1 init done\r\n");
в
main
.
Собери и прошей проект.

Подключи плату к ПК:

Открой терминал (PuTTY, Termite, etc.),
выбери COM-порт CH340E,
скорость 115200 (позже можем скорректировать, если PCLK2 другой).
Нажми Reset на плате:

должен мигать светодиод, как раньше,
в терминал должна прилететь строка
USART1 init done
.
Твои задачи / вопросы
Найди и напиши мне значение
SystemCoreClock
в
system_stm32h7xx.c
, чтобы мы честно знали, какая частота сейчас.
Скажи, удалось ли увидеть строку в терминале.
Что хотелось бы подробнее разобрать:
формулу и точный расчёт
BRR
,
логику флагов
ISR
(TXE, TC и др.),
или структуру RCC и откуда берётся PCLK2?
Когда мы убедимся, что UART стабильно работает, можно будет:

либо углубиться в именно RCC/PLL (сделать частоты такими, как ты планировал: 400 МГц ядро, 50 МГц USART и т.д.),
либо перейти к следующему блоку (например, таймер для точной задержки / системного тика, либо подготовка к SDRAM).


Ты накидал кучу строк информации , тем самым сделав материал менее усваиваемым. Давай по строкам. Написал строку, объяснил что это и зачем, и сделал стоп пока я не скажу далее.

Начнём по‑настоящему построчно.
Сделаем первую маленькую цель: включить тактирование USART1. Пока не отправляем ни одного байта, только включаем модуль.

Работать будем в
main.c
.
Я даю ОДНУ строку кода → объясняю → жду твоё «далее».

Строка 1: включаем тактирование USART1
Добавь в
main()
(после включения GPIOA/GPIOC) такую строку:

RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
Разбор:

RCC

Это указатель на структуру, описывающую блок Reset and Clock Control.
Определён в
stm32h743xx.h
как что‑то типа:
#define RCC ((RCC_TypeDef *) RCC_BASE)
То есть
RCC
указывает на область памяти, где лежат регистры тактирования.
->APB2ENR

APB2ENR
— поле структуры
RCC_TypeDef
.
Полностью: Advanced Peripheral Bus 2 ENable Register.
В этом регистре каждый бит включает тактирование определённого модуля на шине APB2.
Один из битов —
USART1EN
(включает такт для USART1).
RCC_APB2ENR_USART1EN

Это константа‑маска (макрос), определённая в заголовках.
Внутри это, по сути,
(1U << n)
, где
n
— номер бита для USART1EN.
То есть: «младший бит в том месте, где стоит флажок “включить USART1”».
|=

Оператор «побитовое ИЛИ с присваиванием».
x |= y;
значит
x = x | y;
.
Логика: берём текущее значение регистра
APB2ENR
и «добавляем» 1 в нужный бит, не трогая остальные.
Если бит был 0 → станет 1; если был 1 → останется 1.
Зачем это нужно:

Пока бит
USART1EN
= 0, модуль USART1 фактически «обесточен» с точки зрения тактов:
его регистры могут не работать, логика не двигается по тактам.
Эта строка включает тактирование USART1, делая модуль «живым» и готовым к дальнейшей настройке.
Сейчас давай остановимся здесь.

Добавь эту строку в
main()
(например так):
int main(void)
{
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN;

    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;  // <— наша новая строка

    // дальше твой код с LED и т.д.
}
Если хочешь, можешь в отладчике Keil посмотреть:
добавить
RCC->APB2ENR
в Watch,
убедиться, что после выполнения строки бит
USART1EN
стал 1.
Если по этой строке всё понятно — напиши «далее»,
и мы перейдём к СЛЕДУЮЩЕЙ маленькой строке: настроим PA9 и PA10 в режим альтернативной функции для USART1.



Теперь отличное объяснение, именно такое я и имел в виду, всё чётко и понятно. Но сейчас давай немного отвлечёмся и уточним некоторые моменты.

Давай настроим KEIL , Options for Target все окна.
И следующий непонятный пока для меняя момент, как добавить ( как ты говоришь RCC->APB2ENR в Watch. Как это сделать? ).
Давай сразу писать код в отдельных файлах чтоб не путаться и знать где что мы настраиваем. предлагаю создать usart1.c/h. Давай сначала настройки , а затем продолжим.
Сделаем по порядку и спокойно:

настроим проект в Keil (Options for Target) — только нужные вкладки, без лишнего;
покажу, как добавить
RCC->APB2ENR
(и любые регистры/переменные) в Watch;
обсудим структуру проекта и создадим
usart1.c
/
usart1.h
, но пока добавим туда минимум кода.
Буду делить на маленькие логические шаги. Если какой‑то шаг захочешь разобрать детальнее — скажи, остановимся.

1. Настройка проекта в Keil (Options for Target)
Открой Keil → твой проект → в Project Window щёлкни правой кнопкой по имени Target (обычно
Target 1
) → выбери Options for Target 'Target 1'....

Пройдёмся по основным вкладкам.

1.1. Вкладка Device
Здесь ты, скорее всего, уже выбрал STM32H743IITx.

Проверь:

В поле Vendor: STMicroelectronics
В списке видно STM32H743II / STM32H743IITx.
Если это так — хорошо. Ничего менять не надо.

1.2. Вкладка Target
Главное здесь:

Xtal (MHz)

Это не настоящий кварц, а «подсказка» для Keil, какую частоту считать «внешним тактом» для симулятора и отладчика.
У тебя на плате реальный HSE = 25 МГц, но сейчас мы ещё системное тактирование не перенастраивали.
На этом этапе можно:
либо поставить 25.0 (чтобы пометить, что HSE = 25 МГц),
либо оставить значение по умолчанию — это не критично для работы кода, но полезно для правильных Delay в симуляции.
Изначальная память: IROM1, IRAM1
Обычно Keil сам заполняет их для STM32H743. Проверь:

IROM1:
Start:
0x08000000
Size: что‑то вроде
0x200000
(зависит от объёма Flash, у H743 2 МБ).
IRAM1:
Start:
0x24000000
(или
0x30000000
— зависит от шаблона, но важно, чтобы это была реальная SRAM)
Size: какой‑то размер RAM (512KB и т.п.).
Важно: Мы не будем сейчас настраивать внешнюю SDRAM — только убедимся, что прошивка попадает во Flash, а код и стэк — во внутреннюю RAM.

На этом вкладка Target для нас пока завершена.

1.3. Вкладка Output
Здесь важны 2 галочки:

Create HEX File — можно включить, чтобы Keil генерировал
.hex
(удобно для прошивки сторонними программаторами).
Но для отладки через Keil это не обязательно.
Остальное пока можно оставить по умолчанию.
1.4. Вкладка C/C++ (C/C++ (AC6) или C/C++)
Обрати внимание:

Language / Standard

Выбери C11 или C99 (обычно стоит C99 по умолчанию — нам подходит).
Optimization

На время обучения лучше поставить -O0 (без оптимизации), чтобы:
было легче отлаживаться,
отладчик показывал понятные шаги по коду.
Если где‑то есть ползунок Optimization Level — поставь на «0».
Define

Обычно Keil сам прописывает что‑то вроде
STM32H743xx
.
Это нужно, чтобы подтягивались правильные заголовки (
stm32h743xx.h
).
Остальное пока не трогаем.

1.5. Вкладка Debug
Здесь выбирается, чем отлаживаться.

Если у тебя ST‑Link, скорее всего:
поставь ST‑Link Debugger.
Нажми кнопку Settings:
Порт: SW (обычно),
Частота: можно оставить по умолчанию (1–4 МГц).
Ключевое — чтобы отладка вообще работала (ты уже запускал debug, т.е. скорее всего всё настроено).

1.6. Вкладка Utilities
Там обычно стоит Use Debug Driver = ST‑Link.
Включена галочка загрузки прошивки (Flash Download).
Можно ничего не менять, если прошивка уже заливается и работает.
На этом базовые настройки Keil у нас есть.
Если хочешь, можешь кратко описать, что у тебя сейчас в Target / Debug, но это не обязательно, если отладка уже идёт.

Если по Options for Target вопросов нет — напиши, и перейдём ко второй части: Watch.

2. Как добавить
RCC->APB2ENR
в Watch в Keil
Делаем по шагам:

Зайди в режим отладки:

кнопка «Debug» (зелёный жучок), или Debug → Start/Stop Debug Session.
Открой окно Watch:

меню View → Watch Windows → Watch 1 (или просто Watch #1).
В окне Watch увидишь строки типа:

<empty>
или какие‑то уже добавленные выражения.
В первой пустой строке щёлкни по колонке Name и впиши:

RCC->APB2ENR
Нажми Enter.

Keil:

поймёт, что
RCC
— это глобальный символ (указатель на регистры),
APB2ENR
— поле структуры,
покажет текущий HEX и DEC значения этого регистра.
Теперь:

Нажми Run (или F5), потом Stop (Ctrl+F5),

посмотри, как изменяется значение
RCC->APB2ENR
после выполнения строки:

RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
Ты можешь также добавить в Watch:

RCC->AHB4ENR
GPIOA->MODER
GPIOC->ODR
или любую переменную, например
debug_counter
.
Это очень мощный инструмент: ты видишь «живые» регистры.

Если хочешь, на следующем шаге могу прямо по шагам описать:

как поставить breakpoint на строке,
как по шагам (Step Over / Step Into) смотреть изменение конкретного регистра в Watch.
3. Структура проекта: выносим USART1 в отдельный модуль
Ты абсолютно прав: лучше сразу приучаться к структуре:

main.c
— только «высокоуровневый» код (инициализация модулей, основной цикл/RTOS),
usart1.c
/
usart1.h
— всё, что касается настройки и работы с USART1.
Сейчас сделаем первый шаг:

3.1. Создаём файлы usart1.c и usart1.h
В Keil:

В Project Window щёлкни правой кнопкой по группе, куда хочешь добавить файлы (например, группа
Source
или
Application
).
Выбери Add New Item to Group '...'.
Выбери:
C File (.c) → назови
usart1.c
.
Header File (.h) → назови
usart1.h
.
Теперь у тебя в проекте есть два пустых файла.

3.2. Минимальное содержимое usart1.h
Начнём с очень простого — объявим только то, что уже почти было:

// usart1.h
#ifndef USART1_H
#define USART1_H

#include "stm32h7xx.h"

// Инициализация USART1
void USART1_Init(void);

// Отправка одного символа
void USART1_SendChar(char c);

// Отправка строки
void USART1_SendString(const char *s);

#endif // USART1_H
Разбор:

#ifndef / #define / #endif
— include guard:
защищает заголовок от повторного включения.
#include "stm32h7xx.h"
:
чтобы в этом файле были видны типы и объявления для RCC, GPIO, USART1 и т.д.
Объявляем функции, но не пишем реализацию — это сделаем в
usart1.c
.
3.3. Минимальное содержимое usart1.c
Сейчас сюда перенесём тот код, который писали для USART1, но пока только одну строку — включение тактирования, и объясним её ещё раз, уже как часть
USART1_Init
.

В
usart1.c
напиши:

// usart1.c
#include "usart1.h"

void USART1_Init(void)
{
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
}
Пояснение:

#include "usart1.h"
:
Подключаем наш заголовок, чтобы:
были прототипы функций,
был подключен
stm32h7xx.h
(через usart1.h).
void USART1_Init(void)
:
Функция без параметров, ничего не возвращает.
Её задача — подготовить USART1 к работе (сейчас только включаем тактирование; позже добавим настройку пинов, BRR, CR1).
RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
:
То же самое, что мы уже обсудили: включаем тактирование USART1.
3.4. Подключаем usart1 в main.c
Теперь в
main.c
:

Добавь вверху:

#include "stm32h7xx.h"
#include "usart1.h"
Убери из
main.c
прямой доступ к
RCC->APB2ENR
для USART1 (чтобы всё делалось через
USART1_Init
), и оставь:

int main(void)
{
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOCEN;
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN;

    // Инициализация USART1 через отдельный модуль
    USART1_Init();

    // Дальше — LED и прочее
    ...
}
Сейчас
USART1_Init
делает только одно — включает тактирование. Позже мы построчно добавим туда настройку пинов и регистров, как обсуждали.

Дальше
Сейчас предлагаю:

Ты:

проверяешь настройки Keil (если что-то непонятно — задаёшь вопросы по конкретной вкладке),
пробуешь добавить
RCC->APB2ENR
в Watch и посмотреть, как он меняется,
создаёшь
usart1.c
/
usart1.h
и переносишь в них одну строку для включения тактирования USART1.
Пишешь мне:

получилось ли добавить регистр в Watch,
создались ли файлы, нормально ли собирается проект.
Как только это будет — пойдём дальше по твоей схеме:
следующая строка в
USART1_Init
→ подробное объяснение → стоп до твоего “далее”.



Убрал функцию светодиода из main, чтоб не захламлять. получилось вот так: /*

main.c Board STM32H7_CORE
03.01.2026 */
/* Includes */ #include "stm32h7xx.h" #include "main.h"

/* Function prototypes / void USART1_Init(void); / Function prototypes END */

/* USER CODE 0 */

/* USER CODE END 0 */

int main(void) { USART1_Init();

while(1)
{
    
}        
}

/* main.c END */

/*

usart1.h Board STM32H7_CORE
03.01.2026 */ #ifndef USART1_H #define USART1_H
#ifdef __cplusplus extern "C" { #endif

#include "stm32h7xx.h"

// Инициализация USART1 void USART1_Init(void);

// Отправка одного символа void USART1_SendChar(char c);

// Отправка строки void USART1_SendString(const char *s);

#ifdef __cplusplus } #endif

#endif // USART1_H

/*

usart1.c Board STM32H7_CORE
03.01.2026 */
/* Includes */ #include "usart1.h"

/* Function prototypes */

/* Function prototypes END */

/* USER CODE 0 */ void USART1_Init(void) { //включаем тактирование GPIOA RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN; //включаем USART1 на шине APB2
RCC->APB2ENR |= RCC_APB2ENR_USART1EN; }

/* USER CODE 1 */

/* USER CODE END 1 */

Отлично, структура проекта уже хорошая: есть
main.c
,
usart1.c/.h
, инициализация USART1 вынесена отдельно.

Дальше идём строго по строкам в
USART1_Init
, как ты просил. Сейчас у тебя там две строки — разберём каждую, потом добавим следующую (настройку пинов PA9/PA10).

Разбор текущего
USART1_Init
Твой код:

void USART1_Init(void)
{
    //включаем тактирование GPIOA
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN;
    //включаем USART1 на шине APB2  
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
}
Строка 1 внутри функции
RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN;
Смысл:

RCC

указатель на структуру регистров блока тактирования/сброса (Reset and Clock Control),
определён в
stm32h743xx.h
как
(RCC_TypeDef *) RCC_BASE
.
->AHB4ENR

поле структуры: AHB4 ENable Register,
в этом регистре каждый бит включает тактирование отдельного модуля на шине AHB4 (GPIOA, GPIOB, GPIOC, ...).
RCC_AHB4ENR_GPIOAEN

макрос‑маска для бита «включить тактирование порта A»,
внутри это примерно
#define RCC_AHB4ENR_GPIOAEN (1U << n)
(конкретный номер бита определён в RM).
|=

«побитовое ИЛИ с присваиванием»:
x |= y;
эквивалентно
x = x | y;
,
мы устанавливаем в 1 нужный бит, не трогая остальные.
Итого:
Этой строкой ты включаешь тактирование блока GPIOA:
без неё любые операции с
GPIOA->MODER
,
GPIOA->AFR
и т.п. либо не имеют эффекта, либо приводят к ошибкам шины.

Строка 2 внутри функции
RCC->APB2ENR |= RCC_APB2ENR_USART1EN;
Аналогично первой, но для другого регистра:

APB2ENR

Advanced Peripheral Bus 2 ENable Register,
в нём включается тактирование модулей, сидящих на шине APB2 (USART1, TIM1, и др.).
RCC_APB2ENR_USART1EN

маска бита, включающего такт для USART1.
Итого:
Этой строкой ты включаешь тактирование модуля USART1.
Без неё регистры
USART1->CR1
,
BRR
,
TDR
и др. будут «мёртвыми».

Если по этим двум строкам всё понятно — дальше добавляем следующую строку:
перевод пинов PA9 и PA10 в режим альтернативной функции.

Следующая строка: делаем PA9 и PA10 альтернативной функцией
Добавь в
USART1_Init
СЛЕДУЮЩУЮ строку (пока одну, только очищение режимов):

GPIOA->MODER &= ~(GPIO_MODER_MODE9_Msk | GPIO_MODER_MODE10_Msk);
Пока просто добавь и разберём.

Объяснение:

GPIOA

указатель на структуру регистров порта A (
GPIO_TypeDef *
).
->MODER

регистр MODE Register: настраивает режим каждого пина порта,
на каждый пин приходится 2 бита:
00
— вход,
01
— выход,
10
— альтернативная функция,
11
— аналоговый режим.
GPIO_MODER_MODE9_Msk

маска для двух битов, отвечающих за пин 9 (PA9),
внутри это что‑то вроде
(0x3U << (9 * 2))
— то есть
11
сдвинутые на нужную позицию.
GPIO_MODER_MODE10_Msk

маска для двух битов режима пина 10 (PA10).
|

обычное побитовое ИЛИ: объединяем две маски:
mask = mask_pin9 | mask_pin10
.
~(...)

побитовое отрицание: превращает 1→0 и 0→1,
если маска была
...000011110000...
, то после
~
станет
...111100001111...
.
&=

«И с присваиванием»:
x &= y;
→
x = x & y;
,
все биты, где
y
= 0, в
x
обнуляются; где
y
= 1 — остаются как были.
Что делает эта строка:

Она обнуляет (делает
00
) по 2 бита для PA9 и PA10 в регистре
MODER
.
Остальные биты в
MODER
остаются без изменений.
То есть мы «сбрасываем» режим пинов 9 и 10 в состояние «вход» (00), чтобы потом задать нужный режим (альтернативную функцию).
Почему так:

Перед тем как задать новый режим (AF), сначала правильнее очистить старое значение, чтобы не было, например,
11
,
01
и т.п.
Это стандартный приём: «очистить нужные биты → записать туда нужный код».
Сейчас остановимся здесь.

Добавь эту строку в
USART1_Init
после включения тактирования.
При желании, в отладчике:
добавь в Watch
GPIOA->MODER
,
поставь breakpoint на
USART1_Init
,
после выполнения этой строки посмотри, что биты для пинов 9 и 10 действительно стали
00
.
Если по этой строке всё ясно — напиши «далее»,
и мы добавим СЛЕДУЮЩУЮ строку: установим конкретный режим
10
(альтернативная функция) для PA9 и PA10.



далее

Добавляем следующую строку в
USART1_Init
сразу после той, что уже есть с
MODER &= ...
.

Сейчас у тебя должно быть примерно так:

void USART1_Init(void)
{
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

    GPIOA->MODER &= ~(GPIO_MODER_MODE9_Msk | GPIO_MODER_MODE10_Msk);

    // Новая строка:
    GPIOA->MODER |=  (GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1);
}
Разбираем только новую строку:

GPIOA->MODER |=  (GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1);
GPIOA->MODER

Мы снова работаем с регистром режимов порта A.

GPIO_MODER_MODE9_1

Это маска, в которой установлен только «старший» бит из пары для пина 9.
Для каждого пина есть 2 бита:
MODE9[1:0]
.
Варианты:
00
— вход
01
— выход
10
— альтернативная функция
11
— аналог
MODE9_1
означает:
бит 1 = 1
, а
бит 0 = 0
→ получается
10b
.
GPIO_MODER_MODE10_1

То же самое, но для пина 10: устанавливаем старший бит в 1, младший оставляем 0 → снова
10b
.
|
внутри скобок

Объединяем две маски:
(GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1)
В одном числе одновременно стоят единички в нужных местах для пинов 9 и 10.
|=

«ИЛИ с присваиванием»:
x |= mask;
означает: установить в 1 те биты в
x
, которые в маске равны 1.
Мы добавляем нужный код
10
в поля
MODE9
и
MODE10
.
Почему это работает в паре с предыдущей строкой:

До этого мы сделали:
GPIOA->MODER &= ~(GPIO_MODER_MODE9_Msk | GPIO_MODER_MODE10_Msk);
Это обнулило оба бита (сделало
00
) для PA9 и PA10.
Сейчас мы устанавливаем только старший бит →
10
.
В результате:
для PA9:
MODE9 = 10b
→ альтернативная функция,
для PA10:
MODE10 = 10b
→ альтернативная функция.
Итого смысл строки:

Перевести PA9 и PA10 из «входа» в режим альтернативной функции (AF) — это нужно, чтобы пины работали как выводы USART1_TX и USART1_RX, а не как обычные GPIO.

Следующий шаг (после этого) — выбрать какая именно альтернативная функция (AF7 для USART1) через регистр
AFR
.

Если по этой строке всё понятно — напиши «далее»,
и мы добавим одну строку настроек AFR для PA9/PA10 и подробно разберём, как она выбирает AF7.



далее

Теперь настроим AFR — выберем, какая именно альтернативная функция будет у PA9 и PA10. Нам нужна AF7 (USART1).

Сначала добавим одну строку, которая ОЧИЩАЕТ старые AF для пинов 9 и 10, потом разберём её.

В
USART1_Init
после строк с
MODER
добавь:

GPIOA->AFR[1] &= ~((0xFU << ((9U - 8U) * 4U)) | (0xFU << ((10U - 8U) * 4U)));
Сейчас разберём только её.

Что делает регистр AFR
У каждого порта GPIO есть два регистра альтернативных функций:

AFR[0]
— Alternate Function Low, для пинов 0..7,
AFR[1]
— Alternate Function High, для пинов 8..15.
Каждый пин получает 4 бита:

0000: AF0
0001: AF1
...
0111: AF7
...
1111: AF15
Для USART1_TX / RX на PA9 / PA10 используется AF7.

Разбор строки
GPIOA->AFR[1] &= ~((0xFU << ((9U - 8U) * 4U)) | (0xFU << ((10U - 8U) * 4U)));
Разбиваем на части:

GPIOA->AFR[1]

Работаем с регистром альтернативных функций High: пины 8..15.
Наши пины 9 и 10 попадают именно сюда.
0xFU

Это 16-ричное число
0xF
→ двоично
1111b
.
Маска из 4 единиц → удобно для работы с 4-битными полями AF каждого пина.
(9U - 8U) * 4U

Пин 9 имеет индекс 9.
В AFR[1] пин 8 — это поле [3:0], пин 9 — [7:4], пин 10 — [11:8] и т.д.
Поэтому:
9 − 8 = 1 → это «номер» поля внутри AFR[1],
умножаем на 4, потому что на каждый пин приходится 4 бита AF.
Для пина 9:
(9U - 8U) * 4U = 1 * 4 = 4
→ поле AF9 — биты [7:4].
0xFU << ((9U - 8U) * 4U)

Сдвигаем
0000 1111b
(0xF) на 4 бита влево:
Получаем маску
0xF0
на месте поля для пина 9 (биты [7:4] = 1111).
Аналогично для пина 10:

0xFU << ((10U - 8U) * 4U)
10 − 8 = 2 → 2 * 4 = 8 → поле AF10 — биты [11:8].
Маска будет
0xF << 8
=
0xF00
.
(...) | (...)

Побитовое ИЛИ двух масок:
Мы объединяем маску AF9 и маску AF10:
получаем число, в котором 1 стоят во всех 4 битах поля AF9 и AF10.
То есть маска вида:
... 0000 FFF0 FFF0 ...
(с единицами только в полях для пинов 9 и 10).

~(...)

Инверсия (NOT): 1→0, 0→1.
Мы получаем число, в котором:
нули стоят в полях AF9 и AF10 (где мы хотим обнулить),
единицы — во всех остальных битах.
&=

«И с присваиванием»:
x &= mask;
→
x = x & mask;
.
Там, где в маске 0, биты в
AFR[1]
обнуляются.
Там, где в маске 1, биты остаются как были.
Итого:

Эта строка:

ОЧИЩАЕТ (делает
0000
) 4-битовые поля альтернативных функций для пинов PA9 и PA10 в регистре AFR[1], не затрагивая другие пины.

Зачем:

Перед тем как записать туда значение
7
(AF7), мы гарантированно очищаем старое значение (чтобы не оказалось, что там, например, было
1010
от чего-то ещё).
Следующим шагом мы добавим ещё одну строку, которая ЗАПИШЕТ в эти поля число
7
(AF7).

Если по этой строке всё понятно — напиши «далее»,
и мы добавим строку с
|=
и
7 << ...
, чтобы реально выбрать AF7 для PA9 и PA10.



/****************** Bit definition for GPIO_AFRL register ********************/ #define GPIO_AFRL_AFSEL0_Pos (0U) #define GPIO_AFRL_AFSEL0_Msk (0xFUL << GPIO_AFRL_AFSEL0_Pos) /*!< 0x0000000F / #define GPIO_AFRL_AFSEL0 GPIO_AFRL_AFSEL0_Msk #define GPIO_AFRL_AFSEL0_0 (0x1UL << GPIO_AFRL_AFSEL0_Pos) /!< 0x00000001 / #define GPIO_AFRL_AFSEL0_1 (0x2UL << GPIO_AFRL_AFSEL0_Pos) /!< 0x00000002 / #define GPIO_AFRL_AFSEL0_2 (0x4UL << GPIO_AFRL_AFSEL0_Pos) /!< 0x00000004 / #define GPIO_AFRL_AFSEL0_3 (0x8UL << GPIO_AFRL_AFSEL0_Pos) /!< 0x00000008 / #define GPIO_AFRL_AFSEL1_Pos (4U) #define GPIO_AFRL_AFSEL1_Msk (0xFUL << GPIO_AFRL_AFSEL1_Pos) /!< 0x000000F0 / #define GPIO_AFRL_AFSEL1 GPIO_AFRL_AFSEL1_Msk #define GPIO_AFRL_AFSEL1_0 (0x1UL << GPIO_AFRL_AFSEL1_Pos) /!< 0x00000010 / #define GPIO_AFRL_AFSEL1_1 (0x2UL << GPIO_AFRL_AFSEL1_Pos) /!< 0x00000020 / #define GPIO_AFRL_AFSEL1_2 (0x4UL << GPIO_AFRL_AFSEL1_Pos) /!< 0x00000040 / #define GPIO_AFRL_AFSEL1_3 (0x8UL << GPIO_AFRL_AFSEL1_Pos) /!< 0x00000080 / #define GPIO_AFRL_AFSEL2_Pos (8U) #define GPIO_AFRL_AFSEL2_Msk (0xFUL << GPIO_AFRL_AFSEL2_Pos) /!< 0x00000F00 / #define GPIO_AFRL_AFSEL2 GPIO_AFRL_AFSEL2_Msk #define GPIO_AFRL_AFSEL2_0 (0x1UL << GPIO_AFRL_AFSEL2_Pos) /!< 0x00000100 / #define GPIO_AFRL_AFSEL2_1 (0x2UL << GPIO_AFRL_AFSEL2_Pos) /!< 0x00000200 / #define GPIO_AFRL_AFSEL2_2 (0x4UL << GPIO_AFRL_AFSEL2_Pos) /!< 0x00000400 / #define GPIO_AFRL_AFSEL2_3 (0x8UL << GPIO_AFRL_AFSEL2_Pos) /!< 0x00000800 / #define GPIO_AFRL_AFSEL3_Pos (12U) #define GPIO_AFRL_AFSEL3_Msk (0xFUL << GPIO_AFRL_AFSEL3_Pos) /!< 0x0000F000 / #define GPIO_AFRL_AFSEL3 GPIO_AFRL_AFSEL3_Msk #define GPIO_AFRL_AFSEL3_0 (0x1UL << GPIO_AFRL_AFSEL3_Pos) /!< 0x00001000 / #define GPIO_AFRL_AFSEL3_1 (0x2UL << GPIO_AFRL_AFSEL3_Pos) /!< 0x00002000 / #define GPIO_AFRL_AFSEL3_2 (0x4UL << GPIO_AFRL_AFSEL3_Pos) /!< 0x00004000 / #define GPIO_AFRL_AFSEL3_3 (0x8UL << GPIO_AFRL_AFSEL3_Pos) /!< 0x00008000 / #define GPIO_AFRL_AFSEL4_Pos (16U) #define GPIO_AFRL_AFSEL4_Msk (0xFUL << GPIO_AFRL_AFSEL4_Pos) /!< 0x000F0000 / #define GPIO_AFRL_AFSEL4 GPIO_AFRL_AFSEL4_Msk #define GPIO_AFRL_AFSEL4_0 (0x1UL << GPIO_AFRL_AFSEL4_Pos) /!< 0x00010000 / #define GPIO_AFRL_AFSEL4_1 (0x2UL << GPIO_AFRL_AFSEL4_Pos) /!< 0x00020000 / #define GPIO_AFRL_AFSEL4_2 (0x4UL << GPIO_AFRL_AFSEL4_Pos) /!< 0x00040000 / #define GPIO_AFRL_AFSEL4_3 (0x8UL << GPIO_AFRL_AFSEL4_Pos) /!< 0x00080000 / #define GPIO_AFRL_AFSEL5_Pos (20U) #define GPIO_AFRL_AFSEL5_Msk (0xFUL << GPIO_AFRL_AFSEL5_Pos) /!< 0x00F00000 / #define GPIO_AFRL_AFSEL5 GPIO_AFRL_AFSEL5_Msk #define GPIO_AFRL_AFSEL5_0 (0x1UL << GPIO_AFRL_AFSEL5_Pos) /!< 0x00100000 / #define GPIO_AFRL_AFSEL5_1 (0x2UL << GPIO_AFRL_AFSEL5_Pos) /!< 0x00200000 / #define GPIO_AFRL_AFSEL5_2 (0x4UL << GPIO_AFRL_AFSEL5_Pos) /!< 0x00400000 / #define GPIO_AFRL_AFSEL5_3 (0x8UL << GPIO_AFRL_AFSEL5_Pos) /!< 0x00800000 / #define GPIO_AFRL_AFSEL6_Pos (24U) #define GPIO_AFRL_AFSEL6_Msk (0xFUL << GPIO_AFRL_AFSEL6_Pos) /!< 0x0F000000 / #define GPIO_AFRL_AFSEL6 GPIO_AFRL_AFSEL6_Msk #define GPIO_AFRL_AFSEL6_0 (0x1UL << GPIO_AFRL_AFSEL6_Pos) /!< 0x01000000 / #define GPIO_AFRL_AFSEL6_1 (0x2UL << GPIO_AFRL_AFSEL6_Pos) /!< 0x02000000 / #define GPIO_AFRL_AFSEL6_2 (0x4UL << GPIO_AFRL_AFSEL6_Pos) /!< 0x04000000 / #define GPIO_AFRL_AFSEL6_3 (0x8UL << GPIO_AFRL_AFSEL6_Pos) /!< 0x08000000 / #define GPIO_AFRL_AFSEL7_Pos (28U) #define GPIO_AFRL_AFSEL7_Msk (0xFUL << GPIO_AFRL_AFSEL7_Pos) /!< 0xF0000000 / #define GPIO_AFRL_AFSEL7 GPIO_AFRL_AFSEL7_Msk #define GPIO_AFRL_AFSEL7_0 (0x1UL << GPIO_AFRL_AFSEL7_Pos) /!< 0x10000000 / #define GPIO_AFRL_AFSEL7_1 (0x2UL << GPIO_AFRL_AFSEL7_Pos) /!< 0x20000000 / #define GPIO_AFRL_AFSEL7_2 (0x4UL << GPIO_AFRL_AFSEL7_Pos) /!< 0x40000000 / #define GPIO_AFRL_AFSEL7_3 (0x8UL << GPIO_AFRL_AFSEL7_Pos) /!< 0x80000000 */

/* Legacy defines */ #define GPIO_AFRL_AFRL0 GPIO_AFRL_AFSEL0 #define GPIO_AFRL_AFRL1 GPIO_AFRL_AFSEL1 #define GPIO_AFRL_AFRL2 GPIO_AFRL_AFSEL2 #define GPIO_AFRL_AFRL3 GPIO_AFRL_AFSEL3 #define GPIO_AFRL_AFRL4 GPIO_AFRL_AFSEL4 #define GPIO_AFRL_AFRL5 GPIO_AFRL_AFSEL5 #define GPIO_AFRL_AFRL6 GPIO_AFRL_AFSEL6 #define GPIO_AFRL_AFRL7 GPIO_AFRL_AFSEL7

/****************** Bit definition for GPIO_AFRH register ********************/ #define GPIO_AFRH_AFSEL8_Pos (0U) #define GPIO_AFRH_AFSEL8_Msk (0xFUL << GPIO_AFRH_AFSEL8_Pos) /*!< 0x0000000F / #define GPIO_AFRH_AFSEL8 GPIO_AFRH_AFSEL8_Msk #define GPIO_AFRH_AFSEL8_0 (0x1UL << GPIO_AFRH_AFSEL8_Pos) /!< 0x00000001 / #define GPIO_AFRH_AFSEL8_1 (0x2UL << GPIO_AFRH_AFSEL8_Pos) /!< 0x00000002 / #define GPIO_AFRH_AFSEL8_2 (0x4UL << GPIO_AFRH_AFSEL8_Pos) /!< 0x00000004 / #define GPIO_AFRH_AFSEL8_3 (0x8UL << GPIO_AFRH_AFSEL8_Pos) /!< 0x00000008 / #define GPIO_AFRH_AFSEL9_Pos (4U) #define GPIO_AFRH_AFSEL9_Msk (0xFUL << GPIO_AFRH_AFSEL9_Pos) /!< 0x000000F0 / #define GPIO_AFRH_AFSEL9 GPIO_AFRH_AFSEL9_Msk #define GPIO_AFRH_AFSEL9_0 (0x1UL << GPIO_AFRH_AFSEL9_Pos) /!< 0x00000010 / #define GPIO_AFRH_AFSEL9_1 (0x2UL << GPIO_AFRH_AFSEL9_Pos) /!< 0x00000020 / #define GPIO_AFRH_AFSEL9_2 (0x4UL << GPIO_AFRH_AFSEL9_Pos) /!< 0x00000040 / #define GPIO_AFRH_AFSEL9_3 (0x8UL << GPIO_AFRH_AFSEL9_Pos) /!< 0x00000080 / #define GPIO_AFRH_AFSEL10_Pos (8U) #define GPIO_AFRH_AFSEL10_Msk (0xFUL << GPIO_AFRH_AFSEL10_Pos) /!< 0x00000F00 / #define GPIO_AFRH_AFSEL10 GPIO_AFRH_AFSEL10_Msk #define GPIO_AFRH_AFSEL10_0 (0x1UL << GPIO_AFRH_AFSEL10_Pos) /!< 0x00000100 / #define GPIO_AFRH_AFSEL10_1 (0x2UL << GPIO_AFRH_AFSEL10_Pos) /!< 0x00000200 / #define GPIO_AFRH_AFSEL10_2 (0x4UL << GPIO_AFRH_AFSEL10_Pos) /!< 0x00000400 / #define GPIO_AFRH_AFSEL10_3 (0x8UL << GPIO_AFRH_AFSEL10_Pos) /!< 0x00000800 / #define GPIO_AFRH_AFSEL11_Pos (12U) #define GPIO_AFRH_AFSEL11_Msk (0xFUL << GPIO_AFRH_AFSEL11_Pos) /!< 0x0000F000 / #define GPIO_AFRH_AFSEL11 GPIO_AFRH_AFSEL11_Msk #define GPIO_AFRH_AFSEL11_0 (0x1UL << GPIO_AFRH_AFSEL11_Pos) /!< 0x00001000 / #define GPIO_AFRH_AFSEL11_1 (0x2UL << GPIO_AFRH_AFSEL11_Pos) /!< 0x00002000 / #define GPIO_AFRH_AFSEL11_2 (0x4UL << GPIO_AFRH_AFSEL11_Pos) /!< 0x00004000 / #define GPIO_AFRH_AFSEL11_3 (0x8UL << GPIO_AFRH_AFSEL11_Pos) /!< 0x00008000 / #define GPIO_AFRH_AFSEL12_Pos (16U) #define GPIO_AFRH_AFSEL12_Msk (0xFUL << GPIO_AFRH_AFSEL12_Pos) /!< 0x000F0000 / #define GPIO_AFRH_AFSEL12 GPIO_AFRH_AFSEL12_Msk #define GPIO_AFRH_AFSEL12_0 (0x1UL << GPIO_AFRH_AFSEL12_Pos) /!< 0x00010000 / #define GPIO_AFRH_AFSEL12_1 (0x2UL << GPIO_AFRH_AFSEL12_Pos) /!< 0x00020000 / #define GPIO_AFRH_AFSEL12_2 (0x4UL << GPIO_AFRH_AFSEL12_Pos) /!< 0x00040000 / #define GPIO_AFRH_AFSEL12_3 (0x8UL << GPIO_AFRH_AFSEL12_Pos) /!< 0x00080000 / #define GPIO_AFRH_AFSEL13_Pos (20U) #define GPIO_AFRH_AFSEL13_Msk (0xFUL << GPIO_AFRH_AFSEL13_Pos) /!< 0x00F00000 / #define GPIO_AFRH_AFSEL13 GPIO_AFRH_AFSEL13_Msk #define GPIO_AFRH_AFSEL13_0 (0x1UL << GPIO_AFRH_AFSEL13_Pos) /!< 0x00100000 / #define GPIO_AFRH_AFSEL13_1 (0x2UL << GPIO_AFRH_AFSEL13_Pos) /!< 0x00200000 / #define GPIO_AFRH_AFSEL13_2 (0x4UL << GPIO_AFRH_AFSEL13_Pos) /!< 0x00400000 / #define GPIO_AFRH_AFSEL13_3 (0x8UL << GPIO_AFRH_AFSEL13_Pos) /!< 0x00800000 / #define GPIO_AFRH_AFSEL14_Pos (24U) #define GPIO_AFRH_AFSEL14_Msk (0xFUL << GPIO_AFRH_AFSEL14_Pos) /!< 0x0F000000 / #define GPIO_AFRH_AFSEL14 GPIO_AFRH_AFSEL14_Msk #define GPIO_AFRH_AFSEL14_0 (0x1UL << GPIO_AFRH_AFSEL14_Pos) /!< 0x01000000 / #define GPIO_AFRH_AFSEL14_1 (0x2UL << GPIO_AFRH_AFSEL14_Pos) /!< 0x02000000 / #define GPIO_AFRH_AFSEL14_2 (0x4UL << GPIO_AFRH_AFSEL14_Pos) /!< 0x04000000 / #define GPIO_AFRH_AFSEL14_3 (0x8UL << GPIO_AFRH_AFSEL14_Pos) /!< 0x08000000 / #define GPIO_AFRH_AFSEL15_Pos (28U) #define GPIO_AFRH_AFSEL15_Msk (0xFUL << GPIO_AFRH_AFSEL15_Pos) /!< 0xF0000000 / #define GPIO_AFRH_AFSEL15 GPIO_AFRH_AFSEL15_Msk #define GPIO_AFRH_AFSEL15_0 (0x1UL << GPIO_AFRH_AFSEL15_Pos) /!< 0x10000000 / #define GPIO_AFRH_AFSEL15_1 (0x2UL << GPIO_AFRH_AFSEL15_Pos) /!< 0x20000000 / #define GPIO_AFRH_AFSEL15_2 (0x4UL << GPIO_AFRH_AFSEL15_Pos) /!< 0x40000000 / #define GPIO_AFRH_AFSEL15_3 (0x8UL << GPIO_AFRH_AFSEL15_Pos) /!< 0x80000000 */

/* Legacy defines */ #define GPIO_AFRH_AFRH0 GPIO_AFRH_AFSEL8 #define GPIO_AFRH_AFRH1 GPIO_AFRH_AFSEL9 #define GPIO_AFRH_AFRH2 GPIO_AFRH_AFSEL10 #define GPIO_AFRH_AFRH3 GPIO_AFRH_AFSEL11 #define GPIO_AFRH_AFRH4 GPIO_AFRH_AFSEL12 #define GPIO_AFRH_AFRH5 GPIO_AFRH_AFSEL13 #define GPIO_AFRH_AFRH6 GPIO_AFRH_AFSEL14 #define GPIO_AFRH_AFRH7 GPIO_AFRH_AFSEL15

Отлично, ты нашёл кусок из заголовка, который как раз описывает AFR — сейчас связуем его с нашей строкой, чтобы было понятно «откуда что берётся».

Мы уже написали строку:

GPIOA->AFR[1] &= ~((0xFU << ((9U - 8U) * 4U)) | (0xFU << ((10U - 8U) * 4U)));
и посмотрели на неё в общем виде. Теперь давай опираясь на твои макросы AFRH, покажу, как это устроено, и сделаем следующую строку — установку AF7.

Как AFRH описан в заголовке
Из твоего фрагмента:

Для AFRH (пины 8..15):

#define GPIO_AFRH_AFSEL8_Pos     (0U)
#define GPIO_AFRH_AFSEL8_Msk     (0xFUL << GPIO_AFRH_AFSEL8_Pos)   // 0x0000000F

#define GPIO_AFRH_AFSEL9_Pos     (4U)
#define GPIO_AFRH_AFSEL9_Msk     (0xFUL << GPIO_AFRH_AFSEL9_Pos)   // 0x000000F0

#define GPIO_AFRH_AFSEL10_Pos    (8U)
#define GPIO_AFRH_AFSEL10_Msk    (0xFUL << GPIO_AFRH_AFSEL10_Pos)  // 0x00000F00
...
Смысл:

Для каждого пина (8..15) есть:
*_Pos
— позиция младшего бита 4-битного поля,
*_Msk
— маска для этих 4 бит.
Например:
AFSEL9_Pos = 4 → поле AF для пина 9 занимает биты [7:4].
AFSEL10_Pos = 8 → поле AF для пина 10 занимает биты [11:8].
То есть можно было бы писать и так:

GPIOA->AFR[1] &= ~(GPIO_AFRH_AFSEL9_Msk | GPIO_AFRH_AFSEL10_Msk);
это абсолютно эквивалентно нашему варианту с
0xF << ...
.

Твой фрагмент подтверждает как раз то, что мы делаем:
на каждый пин → 4 бита, маска =
0xF << Pos
.

Теперь следующая строка: установить AF7 для PA9 и PA10
После очистки полей AFR (строка с
&= ~(...)
) добавляем НОВУЮ строку:

GPIOA->AFR[1] |=  ((7U << ((9U - 8U) * 4U)) | (7U << ((10U - 8U) * 4U)));
Разберём её.

Часть 1: 7U
7U
— это значение альтернативной функции:

7 (в десятичной) =
0b0111
.
AF7 = USART1 для PA9/PA10 (это написано в таблице альтернативных функций в RM).
То есть мы хотим записать значение 7 в 4-битные поля AF9 и AF10.

Часть 2:
(9U - 8U) * 4U
Для AFR[1]:
индекс поля =
номер_пина - 8
,
каждый пин — 4 бита, значит
* 4
.
Для пина 9:

9U - 8U = 1
,
1 * 4U = 4
→ поле [7:4].
Для пина 10:

10U - 8U = 2
,
2 * 4U = 8
→ поле [11:8].
Часть 3:
7U << ((9U - 8U) * 4U)
Берём 0b0111 (7) и сдвигаем в нужное поле:
для пина 9 →
7 << 4
→ биты [7:4] = 0111,
для пина 10 →
7 << 8
→ биты [11:8] = 0111.
Часть 4:
(...) | (...)
(7U << ((9U - 8U) * 4U)) | (7U << ((10U - 8U) * 4U))
Объединяем два числа:
одно с 7 на месте AF9,
второе с 7 на месте AF10,
в сумме получается маска, где:
AF9 = 7,
AF10 = 7.
Часть 5:
|=
GPIOA->AFR[1] |= ...
Устанавливаем в регистре AFR[1] соответствующие биты в 1/0 так, чтобы поле для пинов 9 и 10 стало равно
0111
(7).
Предыдущей строкой мы эти поля обнулили, так что теперь там будет ровно 7.
Итого смысл строки:

Записать значение AF7 (0b0111) в поля альтернативных функций для PA9 и PA10, то есть сказать железу: «эти пины работают как USART1_TX и USART1_RX».

Альтернативный (эквивалентный) вариант с твоими макросами
Могли бы использовать и твои
GPIO_AFRH_AFSEL9_Msk
/
_Pos
так:

GPIOA->AFR[1] &= ~(GPIO_AFRH_AFSEL9_Msk | GPIO_AFRH_AFSEL10_Msk); // очистка
GPIOA->AFR[1] |=  ((7U << GPIO_AFRH_AFSEL9_Pos) |
                   (7U << GPIO_AFRH_AFSEL10_Pos));                 // установка 7
Это логически то же самое, просто вместо вычисления
(9 - 8) * 4
используем уже готовые
*_Pos
.

Если тебе такой вариант кажется более «читаемым» — можно перейти на него, это нормально.

Сейчас итоговый фрагмент USART1_Init по пинам выглядит так:
void USART1_Init(void)
{
    RCC->AHB4ENR |= RCC_AHB4ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_USART1EN;

    GPIOA->MODER &= ~(GPIO_MODER_MODE9_Msk | GPIO_MODER_MODE10_Msk);
    GPIOA->MODER |=  (GPIO_MODER_MODE9_1   | GPIO_MODER_MODE10_1);

    GPIOA->AFR[1] &= ~((0xFU << ((9U  - 8U) * 4U)) |
                       (0xFU << ((10U - 8U) * 4U)));

    GPIOA->AFR[1] |=  ((7U << ((9U  - 8U) * 4U)) |
                       (7U << ((10U - 8U) * 4U)));
}
По шагам:

Включаем тактирование GPIOA и USART1.
Делаем PA9/PA10 режимом «альтернативная функция».
В AFR[1]:
очищаем старые AF,
записываем 7 (AF7 = USART1).
Если по этой строке с установкой
7U
всё понятно — напиши «далее»,
и следующей строкой займёмся уже настройкой самого USART1: начнём с выбора скорости (BaudRate) через регистр
BRR
и разберём формулу на реальных числах.


PDF
stm32h743vi.pdf

мы ещё не настроили скорость порта и подтяжки. С подтяжками по моему там есть ньюанс, толи в TX или в RX ,где то нужна, а где то нет. А также прикладываю даташит на STM32H743xI/G DS12110 Rev 10

Очень хороший и своевременный шаг — притормозить и увязать то, что мы уже сделали, с требованиями из даташита.

Разделю ответ на три части:

Что именно нам ещё нужно доделать по GPIO для USART1: подтяжки и скорость.
Как правильно выставить подтяжки для TX (PA9) и RX (PA10) с точки зрения схемы и DS.
Логика следующего шага по скорости UART (baudrate) и RCC, но только на уровне плана, без кода.
Пока никакого нового кода не даю — только разбираем, что надо сделать и почему. Если будет окей, дальше пойдём по строкам в
usart1.c
.

1. Что по GPIO уже сделано и чего не хватает
Сейчас в
USART1_Init()
мы:

включили тактирование GPIOA и USART1;
перевели PA9/PA10 в режим альтернативной функции (AF);
настроили AFR[1] на AF7 (USART1).
Это даёт:

линия TX (PA9) при передаче будет дергаться правильно,
линия RX (PA10) будет физически подключена к входу USART1.
Но у GPIO есть ещё два важных аспекта:

Подтяжки (pull-up/pull-down) — регистр
GPIOx->PUPDR
.
Скорость фронтов (скорость выхода) — регистр
GPIOx->OSPEEDR
.
Оба параметра влияют и на электрическую корректность, и на помехоустойчивость, и на качество сигнала для CH340E.

2. Подтяжки для TX и RX: где они нужны и от чего зависят
2.1. Что говорит даташит по I/O (кратко, по смыслу)
В даташите (DS12110 Rev 10):

В разделе 6.3.15 / 7.3.15 описаны I/O характеристики (таблицы
I/O static characteristics
):
там важно, что:

все входы CMOS/TTL,
на входах есть встроенные weak pull-up/pull-down (около 40 кОм),
включение/выключение подтяжки мы делаем через
PUPDR
.
В таблицах портов (Port A alternate functions, Table 10) видно, что:

PA9 → AF7 = USART1_TX
PA10 → AF7 = USART1_RX
Но про подтяжки прямо там не пишут — это наш выбор в зависимости от схемы.
Важнее всего — как у тебя разведена линия с CH340E:

На CH340E со стороны USB–UART моста обычно:
его TX (передатчик) идёт на RX микроконтроллера (PA10),
его RX идёт на TX микроконтроллера (PA9),
на линиях чаще всего уже есть какие-то резисторы и иногда подтяжки.
Если на плате на RX/TX уже стоят резисторы подтяжки (pull-up к 3.3 В) или сам CH340E держит линию в определённом состоянии, то:

дополнительная внутренняя подтяжка в STM32 может быть не обязательна или даже лишняя.
2.2. Общая, практическая рекомендация по подтяжкам UART
TX (PA9, выход МК):

как правило, внутренние подтяжки для TX не нужны,
линия и так активно управляется выводом.
PUPDR
для TX часто оставляют
00
(no pull-up/pull-down).
RX (PA10, вход МК):

важно, чтобы линия никогда не «висела в воздухе», особенно при:
старте МК,
когда CH340E ещё не инициализирован,
при отключенном USB.
Если на твоей схеме нет внешнего резистора подтяжки на RX,
то безопасно включить внутренний pull-up (
PU = 1
),
чтобы RX «по умолчанию» видел логическую 1 (линия не дёргается шумом).
С учётом типичного подключения CH340E:

RX микроконтроллера (PA10) смотрит на TX CH340E.
Если CH340E питание/USB есть, он сам держит линию в стабильном состоянии.
Если питания CH340E нет, а МК живёт — RX может болтаться в воздухе,
тогда внутренний
pull-up
на PA10 предотвратит «мусорные байты» и лишнюю нагрузку по току.
Поэтому разумный план:

PA9 (TX): оставить без подтяжки (PUPDR = 00).
PA10 (RX): включить
pull-up
(PUPDR = 01), если нет внешней подтяжки на плате.
Когда будем писать строку кода для
PUPDR
, я разберу:

почему именно такие биты,
как устроен
GPIOA->PUPDR
(2 бита на пин, аналогично MODER),
что означает
00 / 01 / 10 / 11
.
3. Скорость вывода (OSPEEDR) для линий USART1
3.1. Что такое скорость выхода
В регистре
GPIOx_OSPEEDR
у каждого пина есть 2 бита, определяющие:

низкая скорость (Low),
средняя (Medium),
высокая (High),
очень высокая (Very High).
Это не частота UART, а характеристики драйвера:

насколько крутые/быстрые фронты (как резко растёт/падает напряжение),
насколько сильный ток драйвера разрешён,
влияет на:
ЭМИ (наводки/излучение),
качество сигнала на высоких скоростях.
В даташите (таблицы
Output timing characteristics
, например Table 63 / 160) ты видел:

при разных скоростях и нагрузках (10/30/50 pF) указаны максимальные частоты,
для UART-скоростей типа 115200 или даже 1 Мбит/с достаточно Medium или High.
3.2. Практический выбор для TX/RX
RX (PA10) — вход. Для него OSPEED не важен, он читает сигнал, а не формирует.
TX (PA9) — выход. Для комфортной работы с CH340E:
если скорости до нескольких Мбит/с — Medium или High speed более чем хватает,
чаще всего выбирают High speed (
OSPEEDR = 10
для пина).
Мы сделаем:

PA9: OSPEED = High (потом покажу конкретную строку),
PA10: можно оставить по умолчанию или тоже поставить High — вреда не будет, но на вход не влияет.
4. Скорость UART (baudrate) и RCC — как будем подходить
Ты абсолютно верно заметил:
UART‑у нужна частота тактирования (PCLK2), а это уже про RCC и PLL.

Но чтобы материал лучше усваивался, я предлагаю:

Сначала закончить GPIO для USART1:

PUPDR для PA9/PA10 (подтяжки),
OSPEEDR для PA9 (скорость выхода),
и только потом двигаться к регистрам самого USART (BRR, CR1 и т.д.).
Для BRR (baudrate):

мы выясним из
system_stm32h7xx.c
, какой сейчас
SystemCoreClock
и PCLK2,
по формуле
USARTDIV = f_PCLK / BaudRate
рассчитаем значение,
и снова сделаем одну строку кода → подробное объяснение → стоп.
Предложение по дальнейшим шагам
Если тебе такой темп подходит, предлагаю порядок:

Добавляем в
USART1_Init()
строчку(и) настройки
PUPDR
для PA9/PA10:

сначала очистим соответствующие биты,
потом выставим:
PA9: no pull (00),
PA10: pull-up (01).
Потом добавим настройку
OSPEEDR
:

PA9: High speed (10).
И каждую строку разберём по той же схеме, что MODER/AFR.

Сначала подтяжки.
Если готов — напиши «далее», и я дам одну строку для
PUPDR
с объяснением, как устроены биты и откуда берётся маска.


Очень хороший ход — ты как раз туда смотришь, куда надо: на реальные электрические характеристики, а не просто «чтоб заработало».

Разобьём на две части:

Подтяжки (pull‑up/pull‑down) по даташиту.
Скорость (baudrate) и почему пока можем не лезть в полный RCC.
Буду краток, но по делу. Когда пойдём к коду, снова перейдём в режим «строка → объяснение → стоп».

1. Подтяжки RX/TX: что говорит даташит и что нужно в реальной схеме
Нас интересуют два аспекта:

внутренние подтяжки в самом МК (регистры GPIOx_PUPDR),
внешние резисторы/источники сигнала (CH340E, линии, разъём и т.п.).
1.1. Что умеют ножки по подтяжкам
В разделе «I/O static characteristics» (таблица 60, стр. 137–138 даташита) указано:

Есть weak pull‑up / pull‑down с эквивалентным сопротивлением:
RPU, RPD ≈ 30–50 кОм (см.
RPU
и
RPD
в таблице 60).
Включаются они через регистр
GPIOx_PUPDR
:
00
– нет подтяжки,
01
– pull‑up,
10
– pull‑down,
11
– зарезервировано.
Это универсально для всех портов, включая PA9/PA10.

1.2. Что нужно для TX (PA9, USART1_TX)
TX‑линия:

У нас на плате: STM32 → CH340E (его вход RX).
То есть линия всегда «ведётся» выходом STM32.
Внутренняя подтяжка тут не обязательна:
когда USART включён, он сам держит линию в «1» в неактивном состоянии;
CH340E не будет тянуть её куда‑то странно, он просто принимает.
Следствие:

Для PA9 обычно PUPDR = 00 (без подтяжки) или можно оставить «как есть» (подтяжка сильно не помешает, но и смысла особого нет).
1.3. Что нужно для RX (PA10, USART1_RX)
RX важнее:

Если вход RX повиснет «в воздухе» (например, CH340E отключён, линия длинная, помехи), то:
на приёмнике будут случайные фронты,
USART может «видеть» ложные старт‑биты и мусорные байты.
Поэтому:

Хорошая практика — включить внутренний pull‑up на входе RX:
чтобы при отсутствии внешнего драйвера линия сидела в логической «1» (idle).
Внутренний pull‑up:

порядка 30–50 кОм (см. таблицу 60, RPU),
этого почти всегда достаточно для UART‑линии с CH340E (у него свой push‑pull‑выход, он спокойно переходит эту подтяжку).
Аппаратно в большинстве USB‑UART (в т. ч. CH340E):

TX (со стороны CH340E → наш RX) — активный драйвер, который сам тянет линию к 0/3.3 В.
Поэтому наличие внутреннего pull‑up не мешает: когда CH340 передаёт, он притягивает линию, подтяжка просто создаёт небольшой дополнительный ток (порядка десятков микроампер).
Итого по подтяжкам для нашего случая:

PA9 (TX): можно оставить без подтяжки (
PUPDR = 00
) — опционально.
PA10 (RX): рекомендую включить pull‑up (
PUPDR
выставить в
01
для пина 10).
Когда будем писать код настройки GPIOA в
USART1_Init
, там добавим две новые строки для
PUPDR
, и я объясню каждую.

2. Скорость порта (baudrate) и зависимость от тактирования
Ты прав: «скорость порта завязана на тактирование ядра и прескаллеры». Но тут есть два уровня:

Как сделать «чтобы хоть что‑то заработало» с текущим дефолтным тактом.
Как сделать «правильно и точно» после настройки RCC под твои целевые частоты (400 МГц ядра, 50 МГц PCLK2 и т.д.).
2.1. Что сейчас с тактированием, если мы RCC не трогали
Из Reference Manual (RM0433, раздел RCC, стр. 31–32):

После сброса:
включён HSI = 64 МГц,
SYSCLK = HSI,
делители шин (AHB, APB) стоят по умолчанию (чаще всего делитель = 1 для PCLK2, нужно уточнить в
system_stm32h7xx.c
).
Практически:

Пока мы не меняли SystemClock_Config, скорее всего:
SystemCoreClock
= 64 MHz,
PCLK2 (шина, на которой сидит USART1) тоже 64 MHz или близко к этому (надо будет проверить в
system_stm32h7xx.c
— потом отдельно посмотрим).
Для начала обучения:

можем взять PCLK2 ≈ 64 МГц,
задать baudrate 115200,
вычислить
BRR
по формуле и просто увидеть, что символы реально прилетают в терминал (может с чуть большей/меньшей скоростью, но в пределах допуска).
Когда дойдём до серьёзной настройки RCC (PLL1, делители), мы:

выставим PCLK2 точно = 50 МГц (как ты планируешь),
пересчитаем
BRR
уже честно.
2.2. Формула для BRR
Для обычного режима USART (oversampling = 16, что по умолчанию):

[ USARTDIV = \frac{f_{PCLK}}{\text{BaudRate}} ]

f_PCLK
— частота шины, от которой тактируется USART (для USART1 это PCLK2),
BaudRate — желаемая скорость (например, 115200).
В регистр
USART1->BRR
пишется целое значение
USARTDIV
.

Чтобы округлить:

USARTDIV = (PCLK + BaudRate/2) / BaudRate;
Если, к примеру,
PCLK2 = 64 000 000 Гц
:

64 000 000 / 115 200 ≈ 555.55
С округлением →
556
.
В итоге:
USART1->BRR = 556;
Реальный baud будет немного отличаться от 115200, но это нормально.
Позже, когда настроим PCLK2 = 50 МГц:

50 000 000 / 115 200 ≈ 434.02
→
BRR = 434
.
Тогда скорость будет ещё ближе к номиналу.

3. Как я предлагаю дальше двигаться
Ты поднял два конкретных вопроса:

Подтяжки — мы разобрались:

PA9: без подтяжки;
PA10: включим
pull‑up
(и напишем это в коде).
Скорость — мы временно используем текущие частоты (дефолт RCC) и расчёт BRR.
Когда закончим с базовым USART, вернёмся к настройке RCC/PLL и пересчитаем всё строго.

Дальше предлагаю:

В
USART1_Init
:

дописать строки настройки
GPIOA->PUPDR
для PA9 и PA10 (с объяснением, как мы делали для MODER/AFR),
потом добавим и разберём по строкам установку
USART1->BRR
(с конкретной цифрой, рассчитанной под предположительное PCLK2),
После этого — включим TX/RX в
CR1
и напишем
USART1_SendChar
и
USART1_SendString
.

Если тебе сейчас важнее сначала дописать подтяжки для PA9/PA10, скажи «давай подтяжки» — и я дам ОДНУ строку и объяснение, как раньше.



/**

@file system_stm32h7xx.c
@author MCD Application Team
@brief CMSIS Cortex-Mx Device Peripheral Access Layer System Source File.
This file provides two functions and one global variable to be called from
user application:
 - SystemInit(): This function is called at startup just after reset and
                 before branch to main program. This call is made inside
                 the "startup_stm32h7xx.s" file.
 - SystemCoreClock variable: Contains the core clock, it can be used
                             by the user application to setup the SysTick
                             timer or configure other parameters.
 - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
                            be called whenever the core clock is changed
                            during program execution.
@attention
Copyright (c) 2017 STMicroelectronics.
All rights reserved.
This software is licensed under terms that can be found in the LICENSE file
in the root directory of this software component.
If no LICENSE file comes with this software, it is provided AS-IS.
*/

/** @addtogroup CMSIS

@{ */
/** @addtogroup stm32h7xx_system

@{ */
/** @addtogroup STM32H7xx_System_Private_Includes

@{ */
#include "stm32h7xx.h" #include <math.h>

#if !defined (HSE_VALUE) #define HSE_VALUE ((uint32_t)25000000) /*!< Value of the External oscillator in Hz / #endif / HSE_VALUE */

#if !defined (CSI_VALUE) #define CSI_VALUE ((uint32_t)4000000) /!< Value of the Internal oscillator in Hz/ #endif /* CSI_VALUE */

#if !defined (HSI_VALUE) #define HSI_VALUE ((uint32_t)64000000) /!< Value of the Internal oscillator in Hz/ #endif /* HSI_VALUE */

/**

@} */
/** @addtogroup STM32H7xx_System_Private_TypesDefinitions

@{ */
/**

@} */
/** @addtogroup STM32H7xx_System_Private_Defines

@{ */
/************************* Miscellaneous Configuration ***********************/ /!< Uncomment the following line if you need to use initialized data in D2 domain SRAM (AHB SRAM) / / #define DATA_IN_D2_SRAM */

/* Note: Following vector table addresses must be defined in line with linker configuration. / /!< Uncomment the following line if you need to relocate the vector table anywhere in FLASH BANK1 or AXI SRAM, else the vector table is kept at the automatic remap of boot address selected / / #define USER_VECT_TAB_ADDRESS */

#if defined(USER_VECT_TAB_ADDRESS) #if defined(DUAL_CORE) && defined(CORE_CM4) /*!< Uncomment the following line if you need to relocate your vector Table in D2 AXI SRAM else user remap will be done in FLASH BANK2. / / #define VECT_TAB_SRAM / #if defined(VECT_TAB_SRAM) #define VECT_TAB_BASE_ADDRESS D2_AXISRAM_BASE /!< Vector Table base address field. This value must be a multiple of 0x400. / #define VECT_TAB_OFFSET 0x00000000U /!< Vector Table base offset field. This value must be a multiple of 0x400. / #else #define VECT_TAB_BASE_ADDRESS FLASH_BANK2_BASE /!< Vector Table base address field. This value must be a multiple of 0x400. / #define VECT_TAB_OFFSET 0x00000000U /!< Vector Table base offset field. This value must be a multiple of 0x400. / #endif / VECT_TAB_SRAM / #else /!< Uncomment the following line if you need to relocate your vector Table in D1 AXI SRAM else user remap will be done in FLASH BANK1. / / #define VECT_TAB_SRAM / #if defined(VECT_TAB_SRAM) #define VECT_TAB_BASE_ADDRESS D1_AXISRAM_BASE /!< Vector Table base address field. This value must be a multiple of 0x400. / #define VECT_TAB_OFFSET 0x00000000U /!< Vector Table base offset field. This value must be a multiple of 0x400. / #else #define VECT_TAB_BASE_ADDRESS FLASH_BANK1_BASE /!< Vector Table base address field. This value must be a multiple of 0x400. / #define VECT_TAB_OFFSET 0x00000000U /!< Vector Table base offset field. This value must be a multiple of 0x400. / #endif / VECT_TAB_SRAM / #endif / DUAL_CORE && CORE_CM4 / #endif / USER_VECT_TAB_ADDRESS / /*****************************************************************************/

/**

@} */
/** @addtogroup STM32H7xx_System_Private_Macros

@{ */
/**

@} */
/** @addtogroup STM32H7xx_System_Private_Variables

@{ / / This variable is updated in three ways:
by calling CMSIS function SystemCoreClockUpdate()
by calling HAL API function HAL_RCC_GetHCLKFreq()
each time HAL_RCC_ClockConfig() is called to configure the system clock frequency Note: If you use this function to configure the system clock; then there is no need to call the 2 first functions listed above, since SystemCoreClock variable is updated automatically. */ uint32_t SystemCoreClock = 64000000; uint32_t SystemD2Clock = 64000000; const uint8_t D1CorePrescTable[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};
/**

@} */
/** @addtogroup STM32H7xx_System_Private_FunctionPrototypes

@{ */
/**

@} */
/** @addtogroup STM32H7xx_System_Private_Functions

@{ */
/**

@brief Setup the microcontroller system
    Initialize the FPU setting and  vector table location
    configuration.
@param None
@retval None / void SystemInit (void) { #if defined (DATA_IN_D2_SRAM) __IO uint32_t tmpreg; #endif / DATA_IN_D2_SRAM */
/* FPU settings ------------------------------------------------------------/ #if (__FPU_PRESENT == 1) && (__FPU_USED == 1) SCB->CPACR |= ((3UL << (102))|(3UL << (112))); / set CP10 and CP11 Full Access / #endif / Reset the RCC clock configuration to the default reset state ------------*/

/* Increasing the CPU frequency / if(FLASH_LATENCY_DEFAULT > (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY))) { / Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */ MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT)); }

/* Set HSION bit */ RCC->CR |= RCC_CR_HSION;

/* Reset CFGR register */ RCC->CFGR = 0x00000000;

/* Reset HSEON, HSECSSON, CSION, HSI48ON, CSIKERON, PLL1ON, PLL2ON and PLL3ON bits */ RCC->CR &= 0xEAF6ED7FU;

/* Decreasing the number of wait states because of lower CPU frequency / if(FLASH_LATENCY_DEFAULT < (READ_BIT((FLASH->ACR), FLASH_ACR_LATENCY))) { / Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */ MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, (uint32_t)(FLASH_LATENCY_DEFAULT)); }

#if defined(D3_SRAM_BASE) /* Reset D1CFGR register */ RCC->D1CFGR = 0x00000000;

/* Reset D2CFGR register */ RCC->D2CFGR = 0x00000000;

/* Reset D3CFGR register / RCC->D3CFGR = 0x00000000; #else / Reset CDCFGR1 register */ RCC->CDCFGR1 = 0x00000000;

/* Reset CDCFGR2 register */ RCC->CDCFGR2 = 0x00000000;

/* Reset SRDCFGR register / RCC->SRDCFGR = 0x00000000; #endif / Reset PLLCKSELR register */ RCC->PLLCKSELR = 0x02020200;

/* Reset PLLCFGR register / RCC->PLLCFGR = 0x01FF0000; / Reset PLL1DIVR register / RCC->PLL1DIVR = 0x01010280; / Reset PLL1FRACR register */ RCC->PLL1FRACR = 0x00000000;

/* Reset PLL2DIVR register */ RCC->PLL2DIVR = 0x01010280;

/* Reset PLL2FRACR register */

RCC->PLL2FRACR = 0x00000000; /* Reset PLL3DIVR register */ RCC->PLL3DIVR = 0x01010280;

/* Reset PLL3FRACR register */ RCC->PLL3FRACR = 0x00000000;

/* Reset HSEBYP bit */ RCC->CR &= 0xFFFBFFFFU;

/* Disable all interrupts */ RCC->CIER = 0x00000000;

#if (STM32H7_DEV_ID == 0x450UL) /* dual core CM7 or single core line / if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U) { / if stm32h7 revY*/ /* Change the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) / ((__IO uint32_t)0x51008108) = 0x000000001U; } #endif / STM32H7_DEV_ID */

#if defined(DATA_IN_D2_SRAM) /* in case of initialized data in D2 SRAM (AHB SRAM), enable the D2 SRAM clock (AHB SRAM clock) / #if defined(RCC_AHB2ENR_D2SRAM3EN) RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN | RCC_AHB2ENR_D2SRAM3EN); #elif defined(RCC_AHB2ENR_D2SRAM2EN) RCC->AHB2ENR |= (RCC_AHB2ENR_D2SRAM1EN | RCC_AHB2ENR_D2SRAM2EN); #else RCC->AHB2ENR |= (RCC_AHB2ENR_AHBSRAM1EN | RCC_AHB2ENR_AHBSRAM2EN); #endif / RCC_AHB2ENR_D2SRAM3EN */

tmpreg = RCC->AHB2ENR; (void) tmpreg; #endif /* DATA_IN_D2_SRAM */

#if defined(DUAL_CORE) && defined(CORE_CM4) /* Configure the Vector Table location add offset address for cortex-M4 ------------------/ #if defined(USER_VECT_TAB_ADDRESS) SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; / Vector Table Relocation in Internal D2 AXI-RAM or in Internal FLASH / #endif / USER_VECT_TAB_ADDRESS */

#else /*

Disable the FMC bank1 (enabled after reset).
This, prevents CPU speculation access on this bank which blocks the use of FMC during
24us. During this time the others FMC master (such as LTDC) cannot use it! */ FMC_Bank1_R->BTCR[0] = 0x000030D2;
/* Configure the Vector Table location -------------------------------------/ #if defined(USER_VECT_TAB_ADDRESS) SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; / Vector Table Relocation in Internal D1 AXI-RAM or in Internal FLASH / #endif / USER_VECT_TAB_ADDRESS */

#endif /DUAL_CORE && CORE_CM4/ }

/**

@brief Update SystemCoreClock variable according to Clock Register Values.
    The SystemCoreClock variable contains the core clock , it can
    be used by the user application to setup the SysTick timer or configure
    other parameters.
@note Each time the core clock changes, this function must be called
    to update SystemCoreClock variable value. Otherwise, any configuration
    based on this variable will be incorrect.
@note - The system frequency computed by this function is not the real
      frequency in the chip. It is calculated based on the predefined
      constant and the selected clock source:
      - If SYSCLK source is CSI, SystemCoreClock will contain the CSI_VALUE(*)
      - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(**)
      - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(***)
      - If SYSCLK source is PLL, SystemCoreClock will contain the CSI_VALUE(*),
        HSI_VALUE(**) or HSE_VALUE(***) multiplied/divided by the PLL factors.
    (*) CSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
        4 MHz) but the real value may vary depending on the variations
        in voltage and temperature.
    (**) HSI_VALUE is a constant defined in stm32h7xx_hal.h file (default value
        64 MHz) but the real value may vary depending on the variations
        in voltage and temperature.
    (***)HSE_VALUE is a constant defined in stm32h7xx_hal.h file (default value
         25 MHz), user has to ensure that HSE_VALUE is same as the real
         frequency of the crystal used. Otherwise, this function may
         have wrong result.
    - The result of this function could be not correct when using fractional
      value for HSE crystal.
@param None
@retval None */ void SystemCoreClockUpdate (void) { uint32_t pllp, pllsource, pllm, pllfracen, hsivalue, tmp; uint32_t common_system_clock; float_t fracn1, pllvco;
/* Get SYSCLK source -------------------------------------------------------*/

switch (RCC->CFGR & RCC_CFGR_SWS) { case RCC_CFGR_SWS_HSI: /* HSI used as system clock source */ common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)); break;

case RCC_CFGR_SWS_CSI: /* CSI used as system clock source */ common_system_clock = CSI_VALUE; break;

case RCC_CFGR_SWS_HSE: /* HSE used as system clock source */ common_system_clock = HSE_VALUE; break;

case RCC_CFGR_SWS_PLL1: /* PLL1 used as system clock source */

/* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
SYSCLK = PLL_VCO / PLLR
*/
pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
pllfracen = ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));

if (pllm != 0U)
{
  switch (pllsource)
  {
    case RCC_PLLCKSELR_PLLSRC_HSI:  /* HSI used as PLL clock source */

    hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
    pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );

    break;

    case RCC_PLLCKSELR_PLLSRC_CSI:  /* CSI used as PLL clock source */
      pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    break;

    case RCC_PLLCKSELR_PLLSRC_HSE:  /* HSE used as PLL clock source */
      pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    break;

  default:
      hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)) ;
      pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
    break;
  }
  pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
  common_system_clock =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
}
else
{
  common_system_clock = 0U;
}
break;
default: common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3)); break; }

/* Compute SystemClock frequency --------------------------------------------------*/ #if defined (RCC_D1CFGR_D1CPRE) tmp = D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos];

/* common_system_clock frequency : CM7 CPU frequency */ common_system_clock >>= tmp;

/* SystemD2Clock frequency : CM4 CPU, AXI and AHBs Clock frequency */ SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));

#else tmp = D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos];

/* common_system_clock frequency : CM7 CPU frequency */ common_system_clock >>= tmp;

/* SystemD2Clock frequency : AXI and AHBs Clock frequency */ SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));

#endif

#if defined(DUAL_CORE) && defined(CORE_CM4) SystemCoreClock = SystemD2Clock; #else SystemCoreClock = common_system_clock; #endif /* DUAL_CORE && CORE_CM4 */ }

/**

@} */
/**

@} */
/**

@} */
Отлично, это как раз то, что нужно было увидеть.

Главное из
system_stm32h7xx.c
для нас сейчас:

Вверху файла:
#if !defined  (HSI_VALUE)
  #define HSI_VALUE    ((uint32_t)64000000) /*!< Value of the Internal oscillator in Hz*/
#endif /* HSI_VALUE */
То есть константа
HSI_VALUE
= 64 000 000 Гц.

Глобальные переменные:
uint32_t SystemCoreClock = 64000000;
uint32_t SystemD2Clock   = 64000000;
По умолчанию после сброса они инициализируются тоже 64 МГц.

В
SystemInit()
:
Здесь RCC сбрасывается в дефолт, но не включаются PLL, не настраивается HSE.
В самом конце никакого переключения на PLL/HSE нет, значит системный такт остаётся по умолчанию на HSI.
В
SystemCoreClockUpdate()
:
Если источник SYSCLK = HSI (
RCC_CFGR_SWS_HSI
), то:
common_system_clock = (uint32_t) (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV)>> 3));
А так как ты делители HSI пока не менял,
HSIDIV
= 0 → частота =
HSI_VALUE
= 64 МГц.

Вывод:

Сейчас ядро CM7 реально работает на 64 МГц от HSI.
SystemCoreClock
= 64 000 000.
SystemD2Clock
= 64 000 000 (шифровать детали доменов пока рано, главное — шина тоже 64 МГц).
Для USART1:

Он сидит на шине APB2 (см. блок‑схему на стр. 24 даташита и таблицы альтернативных функций).
Пока делители D1/D2/D3 и APB2 в дефолте, с большой долей вероятности:
PCLK2
=
SystemD2Clock
= 64 МГц.
(Точный разбор D1CFGR/D2CFGR сделаем позже, когда пойдём в глубокий RCC.)
Для наших первых шагов этого более чем достаточно:

Мы можем считать PCLK2 = 64 000 000 Гц
И использовать это для расчёта
BRR
под 115200 бод:
uint32_t pclk2    = 64000000U;
uint32_t baudrate = 115200U;
uint32_t usartdiv = (pclk2 + (baudrate / 2U)) / baudrate; // округление
// Для 64 МГц получится usartdiv = 556
USART1->BRR = usartdiv;
Я предложу это в виде следующей строки, когда мы доберёмся до настройки BRR — опять же, с «строка → объяснение → стоп».

Сейчас логично сделать так:

В
USART1_Init
закончить настройку GPIOA для PA9/PA10, включая подтяжку RX.
Потом добавить строки для
BRR
,
CR1
и сделать простейший
USART1_SendChar
.
Если согласен, следующим шагом давай добавим подтяжки:

GPIOA->PUPDR &= ~(GPIO_PUPDR_PUPD9_Msk | GPIO_PUPDR_PUPD10_Msk);
GPIOA->PUPDR |=  GPIO_PUPDR_PUPD10_0;
Я могу сейчас разобрать СНАЧАЛА первую из этих строк (очистка полей PUPD9/PUPD10), потом вторую (включение pull‑up на PA10), в том же стиле, что с MODER/AFR.

Если готов идти дальше — скажи «давай подтяжки», и начнём с первой строки для
PUPDR
.



с подтяжкой всё понятно, разбирать не надо, идём далее.

Тогда сразу переходим к настройке скорости (BRR) и включению USART1.

Сейчас в
USART1_Init
у тебя (по сути) уже есть:

включение тактирования GPIOA и USART1,
MODER → альтернативная функция,
AFR → AF7 для PA9/PA10,
(подтяжки для PA10 ты сам допишешь, раз там всё понятно).
Теперь добавим настройку регистра
BRR
для скорости 115200 бод при PCLK2 = 64 МГц, и включим TX/RX/USART в
CR1
.

Давай по строкам.

Строка 1: расчёт usartdiv
Добавь в
USART1_Init
(после настройки GPIO, до работы с регистрами USART1):

uint32_t pclk2    = 64000000U;
uint32_t baudrate = 115200U;
uint32_t usartdiv = (pclk2 + (baudrate / 2U)) / baudrate;
Разбор:

uint32_t pclk2    = 64000000U;

uint32_t
— беззнаковое 32‑битное целое.
pclk2
— имя переменной, в которую мы кладём частоту шины APB2.
64000000U
— литерал «64 000 000» с суффиксом
U
(unsigned), чтобы явно указать беззнаковый тип.
Мы берём это значение из
SystemCoreClock
/HSI_VALUE и текущей конфигурации: по умолчанию HSI = 64 МГц, и делители не менялись.
uint32_t baudrate = 115200U;

Желаемая скорость UART — 115200 бит/с.
Значение тоже беззнаковое.
uint32_t usartdiv = (pclk2 + (baudrate / 2U)) / baudrate;

Формула для делителя BRR в режиме oversampling=16: [ USARTDIV = \frac{f_{PCLK}}{\text{BaudRate}} ]
Мы хотим округлить результат до ближайшего целого.
Для этого:
сначала прибавляем половину делителя:
pclk2 + (baudrate / 2U)
,
потом делим на
baudrate
.
Это стандартный приём:
X ≈ round(A/B)
через
(A + B/2) / B
.
Подставляя числа:

pclk2 = 64 000 000
,
baudrate = 115 200
,
baudrate/2 = 57 600
,
числитель:
64 000 000 + 57 600 = 64 057 600
,
usartdiv = 64 057 600 / 115 200 ≈ 556
.
Именно это число потом уйдёт в
USART1->BRR
.

Здесь пока стоп.
Убедись, что эти три строки у тебя вставлены.

Если по ним вопросов нет — напиши «далее», и следующей строкой будет уже:

USART1->BRR = usartdiv;
и мы разберём, что такое BRR и как он влияет на реальную скорость порта.



далее

Добавляем следующую строку прямо после расчёта
usartdiv
:

USART1->BRR = usartdiv;
Разбор:

USART1

Это указатель на структуру регистров конкретного модуля USART1.
В заголовке
stm32h743xx.h
он объявлен как что‑то вроде:
#define USART1 ((USART_TypeDef *) USART1_BASE)
То есть
USART1
— адрес области памяти, где лежат все регистры USART1.
->BRR

BRR
— Baud Rate Register (регистр установки скорости).
В режиме oversampling = 16 (по умолчанию) он содержит целое значение
USARTDIV
.
Из этого значения внутри модуля формируется делитель, по которому строится скорость передачи/приёма.
В примере:

мы записываем туда
556
(результат
(64000000 + 115200/2) / 115200
),
реальная скорость будет примерно: [ F_{baud} = \frac{PCLK2}{BRR} ≈ \frac{64,000,000}{556} ≈ 115,000 \text{ бод} ]
Это очень близко к 115200, UART‑приёмники спокойно это переваривают.
= usartdiv;

Мы просто кладём вычисленный делитель в этот регистр.
Зачем эта строка:

Без неё USART1 будет считать
BRR
нулём (или каким‑то значением после сброса) → скорость будет вообще не той, что ожидается, и терминал не поймёт поток.
Это — «сердце» настройки скорости.
Если по BRR всё понятно, следующий шаг — включить сам USART1 и его TX/RX в регистре
CR1
.

Дальше я предложу три строки:

USART1->CR1 = 0;                 // сброс настроек
USART1->CR1 |= USART_CR1_TE;     // включить передатчик
USART1->CR1 |= USART_CR1_RE;     // включить приёмник
USART1->CR1 |= USART_CR1_UE;     // включить USART
И опять же будем разбирать по одной.

Если готов — напиши «далее», и начнём с первой:
USART1->CR1 = 0;
.



далее

Добавляем первую строку настройки
CR1
в
USART1_Init
сразу после
USART1->BRR = usartdiv;
:

USART1->CR1 = 0;
Разбор:

CR1

Это основной Control Register 1 для USART.
В нём много битов:
UE
— USART Enable (включение модуля),
TE
— Transmitter Enable (передатчик),
RE
— Receiver Enable (приёмник),
биты, задающие длину слова, контроль чётности, режимы прерываний и т.д.
USART1->CR1 = 0;

Мы явно обнуляем весь регистр.
То есть:
выключаем USART1 (
UE = 0
),
выключаем TX и RX,
сбрасываем все режимы к «0» (дефолт).
Зачем так делать:

После сброса какие‑то биты могут быть в известных, но не всегда удобных нам значениях.
Возможно, позже мы захотим переписать инициализацию, и чтобы не носить в голове «что там было раньше», проще всё сбросить и включить только то, что нам нужно.
Это очень распространённый приём: «сначала обнуляем, потом выставляем флаги по одному».
Если по этой строке вопросов нет — добавляем следующую, уже включающую передатчик:

USART1->CR1 |= USART_CR1_TE;
Если готов — напиши «далее», и разберём её.



далее

Добавляем следующую строку:

USART1->CR1 |= USART_CR1_TE;
Разбор:

USART_CR1_TE

Это макрос‑маска для бита TE (Transmitter Enable) в регистре
CR1
.
В
stm32h743xx.h
он определён примерно как:
#define USART_CR1_TE  (0x1U << n)
где
n
— номер бита TE.
То есть
USART_CR1_TE
= число, в котором установлен ровно один бит TE, а остальные нули.
|=

Оператор «побитовое ИЛИ с присваиванием»:
x |= y;  // то же, что x = x | y;
Он добавляет 1 в те биты
x
, где
y
имеет 1, не трогая остальные.
Что реально происходит:

CR1
у нас перед этим обнулён (
USART1->CR1 = 0;
).
После этой строки:
бит TE становится = 1,
все остальные биты CR1 остаются 0.
Физический смысл:

Мы разрешаем работу передатчика USART1:
модуль начинает управлять линией TX (PA9 в режиме AF7),
при записи в регистр
TDR
данные начнут уходить «в провод».
Важно:

Без
TE = 1
запись в
TDR
не запустит передачу — TX будет молчать.
Следующей строкой мы включим приёмник:

USART1->CR1 |= USART_CR1_RE;
Если готов — напиши «далее», и разберём эту строку.



далее

Добавляем строку:

USART1->CR1 |= USART_CR1_RE;
Разбор:

USART_CR1_RE
Макрос‑маска для бита RE (Receiver Enable) в регистре
CR1
.
Внутри —
1U << m
, где
m
— номер бита RE.
То есть это число с одним установленным битом, соответствующим «включить приёмник».
|=
Как и раньше:
x |= y;
→
x = x | y;
.
Мы включаем бит RE, не трогая остальные.
Итог:
После трёх строк:

USART1->CR1 = 0;
USART1->CR1 |= USART_CR1_TE;
USART1->CR1 |= USART_CR1_RE;
В
CR1
:

TE = 1
→ передатчик включён,
RE = 1
→ приёмник включён,
другие биты = 0 (формат кадра — 8N1, без чётности, по умолчанию).
Осталось включить сам USART — бит UE.

Следующая строка:

USART1->CR1 |= USART_CR1_UE;
Если готов — напиши «далее», и разберём её, а потом подведём итог по всей функции
USART1_Init
и напишем первую простую
USART1_SendChar
.



далее

Добавляем последнюю строку включения USART1:

USART1->CR1 |= USART_CR1_UE;
Разбор:

USART_CR1_UE
Макрос‑маска для бита UE (USART Enable) в регистре
CR1
.
Внутри —
1U << k
, где
k
— номер бита UE.
Этот бит — «главный выключатель» модуля USART:
0
— модуль отключён (внутренняя логика стоит),
1
— модуль включён, начинает работать с теми настройками, которые мы заложили.
|=
Всё так же: устанавливаем конкретный бит, не трогая остальные.
Что в итоге:
После всех строк в
USART1_Init
(часть, касающаяся USART1):

uint32_t pclk2    = 64000000U;
uint32_t baudrate = 115200U;
uint32_t usartdiv = (pclk2 + (baudrate / 2U)) / baudrate;

USART1->BRR = usartdiv;

USART1->CR1 = 0;                 // сброс настроек
USART1->CR1 |= USART_CR1_TE;     // включить передатчик
USART1->CR1 |= USART_CR1_RE;     // включить приёмник
USART1->CR1 |= USART_CR1_UE;     // включить сам USART
Модуль USART1:

знает свою скорость (через BRR),
имеет включённый TX и RX,
полностью запущен (UE = 1),
формат кадра по умолчанию — 8 бит данных, без чётности, 1 стоп‑бит (8N1), так как соответствующие биты CR1/CR2/CR3 мы не трогали (они остались 0).
Теперь у нас:

GPIO для PA9/PA10 настроены (AF7 + режим AF + подтяжка RX),
тактирование включено (GPIOA + USART1),
BRR настроен под 115200 бод при PCLK2 = 64 МГц,
CR1 включает TX, RX, UE.
Следующий логичный шаг — написать функцию отправки одного символа через USART1 и разобрать flags TXE/TC.

Предлагаю начать с такой функции в
usart1.c
:

void USART1_SendChar(char c)
{
    while ((USART1->ISR & USART_ISR_TXE_TXFNF) == 0U)
    {
        // ждём, пока передаточный буфер освободится
    }

    USART1->TDR = (uint8_t)c;
}
Сделаем по твоему же принципу:

сначала разберём строку с
while ((USART1->ISR & USART_ISR_TXE_TXFNF) == 0U)
,
затем строку
USART1->TDR = (uint8_t)c;
.
Если согласен двигаться дальше таким образом — напиши «далее», и начнём с первой строки цикла ожидания.
