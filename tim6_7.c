/*
 * tim6_7.c    Board STM32H7_CORE
 * 08.01.2026
 */
 
/* Includes */

#include "tim6_7.h"
#include <stdint.h>
#include <stdio.h>  // Для sprintf
#include "usart1.h"

/* Function prototypes */

    // Глобальная переменная для подсчета миллисекунд.
    // Ключевое слово 'volatile' критически важно: оно сообщает компилятору,
    // что значение переменной может измениться в любой момент (например, в прерывании).
    static volatile uint32_t ms_tick_counter = 0;
    
/* Function prototypes END */

/* USER CODE 0 */

void SysTick_Tim_Init(void)
{
    // 1. Включение тактирования таймера.
    // TIM6 находится на шине APB1. Включаем соответствующий бит в регистре RCC.
    // Это все равно что подать питание на микросхему таймера.
    RCC->APB1LENR |= RCC_APB1LENR_TIM6EN;
    
    // 2. Короткая пауза для стабилизации тактирования.
    // Чтение регистра после записи гарантирует, что команда дошла до периферии,
    // прежде чем мы начнем её настраивать.
    volatile uint32_t temp = RCC->APB1LENR;
    (void)temp;             // Пустая операция, чтобы компилятор не удалил чтение.
    
    // 3. Остановка и сброс таймера перед настройкой.
    // Бит 0 (CEN) в регистре CR1 отвечает за включение/выключение счёта.
    CLEAR_REG(TIM6->CR1);  // Устанавливаем весь регистр в 0, отключая таймер.
    
    
    // 4. НАСТРОЙКА ДЛЯ 1 МС ПРИ 100 МГц:
    // Формула периода: T = (PSC + 1) ? (ARR + 1) / F_TIM
    // Цель: T = 0.001 с (1 мс) при F_TIM = 100 000 000 Гц
    // Вариант 1: ARR = 999, PSC = 99
    //   T = (99+1) ? (999+1) / 100 000 000 = 100 ? 1000 / 100 000 000 = 0.001 с
    // Вариант 2: ARR = 99, PSC = 999 (меняем местами)
    //   T = (999+1) ? (99+1) / 100 000 000 = 1000 ? 100 / 100 000 000 = 0.001 с
    
    // Выбираем вариант 2: ARR = 99, PSC = 999
    // Почему? Потому что это дает более точную регулировку при изменении периода
    WRITE_REG(TIM6->PSC, 999U);   // Предделитель: делитель = 1000
    WRITE_REG(TIM6->ARR, 99U);    // Автоперезагрузка: считаем от 0 до 99 (100 тактов)
    
    // 5. Разрешение прерывания по событию обновления (переполнения).
    // Бит 0 (UIE) в регистре DIER (DMA/Interrupt Enable Register) включает
    // генерацию прерывания, когда счётчик достигает значения ARR.
    SET_BIT(TIM6->DIER, TIM_DIER_UIE);
    
    // 6. Принудительная генерация события обновления.
    // Бит 0 (UG) в регистре EGR (Event Generation Register) заставляет таймер
    // немедленно обновить значения регистров PSC и ARR и сбросить счётчик.
    // Это необходимо для корректного старта с заданными настройками.
    SET_BIT(TIM6->EGR, TIM_EGR_UG);
    
    // 7. Настраиваем контроллер прерываний NVIC
    // Приоритет 0 - наивысший (можно изменить по необходимости)
    NVIC_SetPriority(TIM6_DAC_IRQn, 0);
    NVIC_EnableIRQ(TIM6_DAC_IRQn);
    
    // 8. Сбрасываем счетчик миллисекунд
    ms_tick_counter = 0;
    
    // 9. (ОПЦИОНАЛЬНО) Включаем таймер сразу после инициализации
    //SET_BIT(TIM6->CR1, TIM_CR1_CEN);
}

    // Включение счёта таймера. С этого момента счётчик CNT начнёт увеличиваться
    // на каждом такте, с учётом предделителя PSC.
void SysTick_Tim_Enable(void)
{
    TIM6->CR1 |= TIM_CR1_CEN;
}

// Остановка счёта таймера. Счётчик CNT замораживается на текущем значении.
void SysTick_Tim_Disable(void)
{
    TIM6->CR1 &= ~TIM_CR1_CEN;
}

    // Возвращает текущее количество миллисекунд с начала работы.
    // Тип 'volatile' гарантирует, что функция всегда читает актуальное значение
    // из оперативной памяти, а не устаревшее значение из регистра процессора.
uint32_t SysTick_Tim_GetTick(void)
{
    return ms_tick_counter;
}

    // Обработчик прерывания TIM6.
    // Имя этой функции жестко задано в векторе прерываний в startup-файле (startup_stm32h743xx.s).
    // Система автоматически вызовет эту функцию при возникновении прерывания от TIM6.
void TIM6_DAC_IRQHandler(void)
{
    // 1. Проверка источника прерывания.
    // Бит 0 (UIF) в регистре SR (Status Register) устанавливается в 1 аппаратно,
    // когда происходит событие обновления (счётчик достигает ARR).
    if (TIM6->SR & TIM_SR_UIF)
    {
        // 2. ОЧЕНЬ ВАЖНО: Сброс флага прерывания.
        // Запись 0 в бит флага очищает его. Если этого не сделать,
        // микроконтроллер будет снова и снова заходить в это прерывание,
        // зависнув в бесконечном цикле.
        CLEAR_BIT(TIM6->SR, TIM_SR_UIF);
        
        // 3. Инкремент счётчика миллисекунд.
        // Каждый вход в это прерывание означает, что прошла 1 миллисекунда.
        ms_tick_counter++;
        
        // Здесь можно добавить код, который должен выполняться каждую 1 мс
        // Например, обновление таймеров, опрос кнопок и т.д.
    }
}

/* USER CODE END 0 */

/* USER CODE 1 */

// Задержка в миллисекундах (НЕБЛОКИРУЮЩАЯ)
void delay_ms(uint32_t ms)
{
    uint32_t start_tick = SysTick_Tim_GetTick();
    
    // Корректная работа при переполнении счетчика (каждые ~49.7 дней)
    while((SysTick_Tim_GetTick() - start_tick) < ms)
    {
        // Здесь можно делать полезную работу!
        // Например, проверять флаги, обрабатывать данные
        __asm volatile("nop"); // Или просто пустая операция
    }
}



/* USER CODE END 1 */

/* USER CODE 2 */





/* USER CODE END 2 */

/* USER CODE 3 */





/* USER CODE END 3 */

/* USER CODE 4 */



/* USER CODE END 4 */

/* tim6_7.c END */
